\chapter{Implementazione}

In questo capitolo andremo a delineare e descrivere gli aspetti fondamentali ed essenziali relativi all'attività di implementazione.\\

Inizieremo con una presentazione della struttura generale dei programmi assieme ad una descrizione accurata dei componenti utilizzati e delle scelte effettuate in fase di progettazione.\\

In seguito procederemo con un'attenta analisi degli algoritmi implementati, ovvero il l'algoritmo per il calcolo degli equilibri di Nash, quello per il calcolo dell'ottimo relativo alla funzione di benessere sociale utilitario e quello per il calcolo dell'ottimo relativo alla funzione di benessere sociale egalitario.\\
Tale sezione sarà caratterizzata dall'utilizzo di pseudocodice per ciascuno degli algoritmi in modo tale da rendere più comprensibile la descrizione dei cicli e delle operazioni.\\

Tratteremo in modo approfondito questa porzione del documento poiché precede la sezione relativa alla sperimentazione effettuata attraverso i programmi implementati e dunque è di fondamentale importanza.\\

\section{Struttura generale}
\justify

Procediamo presentando la struttura generale relativa programmi implementati.\\ 
Quest'ultima è rappresentata attraverso una struttura ad albero che riproduce una porzione di filesystem partendo dalla root del progetto.\\
Al fine di rendere più chiara la lettura viene inoltre fornita un breve leggenda sulla nomenclatura utilizzata.

\begin{itemize}
	\item La nomenclatura \textbf{nome.dir} indica che l'oggetto è una cartella
	\item La nomenclatura \textbf{nome.edgelist} indica che l'oggetto è un file con estensione .edgelist (oggetto principale modellato dal programma)
	\item La nomenclatura \textbf{nome.dot} indica che l'oggetto è un file con estensione .dot (oggetto utilizzato su macchine GNU/Linux per il disegno attraverso la libreria PyGraphViz in fase di debug)
	\item le lettere \textbf{X,K,Y,Z,H,W} rappresentano numeri casuali (sono utilizzate per descrivere la moltitudine di cartelle, grafi creati e risultati, ottenuti durante un generale caso d'uso dei programmi)
	\item la nomenclatura \textbf{nome.init} indica che l'oggetto è un file con estensione .init (oggetto utilizzato in fase di lettura per salvare le caratteristiche dei grafi (nodi, archi, pesi, colorazione) e dei colori (colori, profitti))
	\item la nomenclatura \textbf{nome.out} indica che l'oggetto è un file con estensione .out (oggetto utilizzato in fase di lettura per salvare i risultati derivanti da esecuzioni singole o multiple usando gli algoritmi per il calcolo del nash, dell'ottimo con funzione di benessere sociale utilitario e dell'ottimo con funzione di benessere sociale egalitario)
\end{itemize}

Descriviamo ora la funzione basilare di alcuni componenti dell'albero sottostante rappresentante un esempio generale relativo ad un caso d'uso dei programmi.

\begin{itemize}
	\item La cartella \textbf{generator} contiene al suo interno l'intera struttura relativa al generatore di grafi
	\item La cartella \textbf{gen} contiene i risultati delle generazioni singole di grafi
	\begin{enumerate}
		\item Al suo interno vi sono X cartelle gen-dir-X (il nome viene assegnato dinamicamente dall'utente) generate dinamicamente
		\item Ciascuna cartella contiene il risultato di una generazione singola di un grafo sotto forma di una coppia di file .edgelist e .dot (utilizzato solo in fase di debug)
		\item Ogni gruppo cartella-file.edgelist-file.dot rappresenta il risultato di una generazione singola
	\end{enumerate}
	\item La cartella \textbf{m-gen} contiene i risultati delle generazioni multiple di grafi
	\begin{enumerate}
		\item Al suo interno vi sono Y cartelle m-gen-dir-Y (il nome viene assegnato dinamicamente dall'utente) generate dinamicamente
		\item Ciascuna cartella contiene il risultato di una generazione multipla di grafi sotto forma di molteplici coppie (nell'esempio K,Z,...) di file .edgelist e .dot (utilizzato solo in fase di debug)
		\item Ogni gruppo cartella-file.edgelist-file.dot-file.edgelist-file.dot-... indica il risultato di una generazione multipla
	\end{enumerate}
	\item Il file \textbf{generator.py} contiene al suo interno il codice del generatore di grafi scritto interamente in linguaggio Python
\end{itemize}

\begin{itemize}
	\item La cartella \textbf{reader} contiene al suo interno l'intera struttura relativa al lettore di grafi
	\item La cartella \textbf{result} contiene i risultati delle letture / sperimentazioni su grafi singoli
	\begin{enumerate}
		\item Al suo interno vi sono H cartelle result-dir-H (il nome viene preso dinamicamente dal grafo in lettura) generate dinamicamente
		\item Ciascuna cartella contiene il singolo risultato di una lettura / sperimentazione su un grafo sotto forma di una coppia di file .init e .out
		\item Ogni gruppo cartella-file.init-file.out rappresenta il risultato di una singola lettura / sperimentazione 
	\end{enumerate}
	\item La cartella \textbf{m-result} contiene i risultati delle letture / sperimentazioni su molteplici grafi
	\begin{enumerate}
		\item Al suo interno vi sono W cartelle m-result-dir-W (il nome viene preso dinamicamente dalla cartella relativa alla moltitudine di grafi in lettura) generate dinamicamente
		\item Ciascuna cartella contiene multipli risultati di multiple letture / sperimentazioni su grafo multipli sotto forma di una coppia di file .init e .out
		\item Ogni gruppo cartella-file.init-file.out rappresenta il risultato di una lettura / sperimentazione multipla
	\end{enumerate}
	\item Il file \textbf{reader.py} contiene al suo interno il codice del lettore di grafi scritto interamente in linguaggio Python 
\end{itemize}

\newpage
\dirtree{%
.1 /.
.2 generator.dir.
.3 gen.dir.
.4 gen-dir-1.dir.
.5 graph-1.edgelist.
.5 graph-1.dot.
.4 .....
.4 gen-dir-X.dir.
.5 graph-X.edgelist.
.5 graph-X.dot.
.3 m-gen.dir.
.4 m-gen-dir-1.dir. 
.5 graph-1.edgelist.
.5 graph-1.dot.
.5 .....
.5 graph-K.edgelist.
.5 graph-K.dot.
.4 .....
.4 m-gen-dir-Y.dir.
.5 graph-1.edgelist.
.5 graph-1.dot.
.5 .....
.5 graph-Z.edgelist.
.5 graph-Z.dot.
.3 generator.py.
.2 reader.dir.
.3 result.dir.
.4 result-dir-1.dir.
.5 graph-1.init.
.5 graph-1.out.
.4 .....
.4 result-dir-H.dir.
.5 graph-H.init.
.5 graph-H.out.
.3 m-result.dir.
.4 m-result-dir-1.dir.
.5 graph-1.init.
.5 graph-1.out.
.4 .....
.4 m-result-dir-W.dir.
.5 graph-W.init.
.5 graph-W.out.
}

\section{Componenti utilizzati e progettazione}
\justify
I programmi generator.py e reader.py sono stati interamente scritti utilizzando il linguaggio Python [versione 3.6.5].\\

Il codice è stato scritto utilizzando differenti editor di testo (vim [neovim], spacemacs, sublime-text, atom,...) e testato su diverse macchine GNU/Linux e Windows, in particolare su differenti shell (bash, zsh, fish) e su cmd.\\

Per agevolare il processo di progettazione e scrittura del codice l'intera struttura del progetto è stata caricata in una repository sul sito github e gestita in remoto (attraverso il software git).\\

Per questioni di compatibilità e versatilità è stata utilizzata in modo massiccio la libreria standard relativa al linguaggio Python per effettuare la quasi totalità delle operazioni in entrambi i programmi.\\

La versione di riferimento della libreria è quella associata alla versione del linguaggio utilizzato, dunque la 3.6.5.\\

Al fine di trascurare alcuni aspetti relativi alla strutturazione e costruzione dei grafi è stata utilizzata una potente libreria per la creazione e la manipolazione di questi oggetti matematici, ovvero NetworkX.\\

Tale scelta di progettazione ha permesso al sottoscritto di concentrarsi maggiormente sulla progettazione e sull'ottimizzazione degli algoritmi.\\

Inoltre tale scelta ha consentito al sottoscritto di rendere totalmente dinamici i processi di creazione e lettura dei grafi, ciò ha facilitato di molto il carico di lavoro in fase di sperimentazione.\\

La libreria standard del linguaggio Python è stata utilizzata in particolare per rendere totalmente dinamica e cross-platform la gestione del filesystem.\\

Ciò è stato necessario per garantire il funzionamento asincrono del generatore e del lettore, in modo tale da facilitare il lavoro in fase di sperimentazione.\\

Le fasi di generazione e lettura dei grafi infatti sono state completamente separate al livello di utilizzo, per fare ciò è stato necessario manipolare efficientemente il filesystem in modo da salvare i grafi creati e i risultati delle sperimentazioni su file.\\

Tali operazioni sono perfettamente funzionanti sia su sistemi che rispettano lo standard POSIX (Sistemi Unix-like) per il filesystem sia per sistemi che non lo rispettano (Sistemi Windows), dunque l'intero progetto è totalmente cross-platform e può essere facilmente migrato rendendo la portabilità un importante fattore di forza di quest'ultimo.\\

Il formato principale manipolato dai programmi è il formato .edgelist che analizzeremo in seguito.\\

In fase di debug è stata utilizzata la libreria di disegno MatPlotLib per rappresentare i grafi, quest'ultima è integrata in modo nativo all'interno della libreria NetworkX, dunque tale scelta di utilizzo ha reso più facili le operazioni di analisi e debug.\\

Un'altra libreria che è stata utilizzata in fase di analisi e debug per rappresentare i grafi in ambiente GNU/Linux è la libreria di disegno PyGraphViz.\\

Anche quest'ultima è integrata in modo nativo all'interno della libreria NetworkX.\\

Il formato di descrizione testuale dei grafi .dot è stato utilizzato solo in fase di debug in ambiente GNU/Linux assieme alla libreria di disegno PyGraphViz, dunque possiamo tralasciare la sua definizione e descrizione poiché non viene utilizzato all'interno dei programmi durante l'esecuzione.\\

Altre librerie minori sono state scelte in fase di progettazione ed utilizzate all'interno dei programmi, ad esempio la libreria per la colorazione dell'output testuale su terminal emulators cross-platform Colorama è stata utilizzata in fase di analisi e debug per semplificare e rendere più chiara la lettura dell'output relativo all'esecuzione degli algoritmi.\\

Un altro esempio è l'utilizzo della libreria cross-platform Pick, che rende semplice ed efficace la selezione delle opzioni all'interno dei terminal emulators durante l'esecuzione dei programmi.\\

L'elenco completo delle librerie utilizzate all'interno dei programmi è il seguente.

\begin{itemize}
	\item Python Standard Library (Python 3.6.5 - Python 2.7.14)\\
	https://docs.python.org/3/library/
	\item NetworkX Library (NetworkX 2.1)\\ 	
	https://pypi.org/project/networkx/	
	\item Matplotlib Library (Matplotlib 2.2)\\
	https://pypi.org/project/matplotlib/
	\item Pick Library (Pick 0.6.4)\\
	https://pypi.org/project/pick/
	\item Pydot Library (Pydot 1.2.4)\\
	https://pypi.org/project/pydot/
	\item Graphviz Library (Graphviz 0.8.2)\\
	https://pypi.org/project/graphviz/
	\item PyParsing Library (PyParsing 2.2.0)\\
	https://pypi.org/project/pyparsing/
	\item Colorama Library (Colorama 0.3.9)\\
	https://pypi.org/project/colorama/
\end{itemize}

Per il funzionamento completo dei programmi è necessaria l'installazione di Python e dei suddetti componenti attraverso l'uso del modulo pip e/o l'uso di package manager (apt, pacman, ...).\\

Procediamo ora nella trattazione descrivendo il funzionamento dei programmi generator.py e reader.py.\\
Saranno poi analizzati in modo approfondito gli algoritmi per il calcolo degli equilibri di Nash e degli ottimi.\\

\section{generator.py : il generatore di grafi}
\justify
Il programma generator.py è un generatore dinamico di grafi scritto interamente in Python in grado di semplificare le operazioni di creazione e manipolazione di questi oggetti matematici e in grado di creare automaticamente tutte le strutture di filesystem necessarie al salvataggio dei grafi generati su file.\\

Il programma come specificato in precedenza è completamente cross-platform e per ciò che riguarda la gestione del filesystem è stato accuratamente ottimizzato per non generare conflitti e problemi di inconsistenza dei dati.\\

Principalmente il programma utilizza due moduli principali necessari al corretto funzionamento dello stesso, la Standard Library del linguaggio Python per le funzioni di base e la libreria NetworkX per la creazione e manipolazione dei grafi.\\

Di seguito vengono riportate le caratteristiche del programma assieme ad un esempio generale di un caso d'uso.\\

Per prima cosa vengono impostati i motori di disegno, ovvero le librerie MatPlotLib e PyGraphViz.\\
Quest'ultima è stata utilizzata solo in ambiente GNU/Linux in fase di debug, dunque non è disponibile per l'utente.\\

In compenso è però disponibile per l'utente la libreria MatPlotLib che consente a quest'ultimo, qualora volesse, di disegnare al termine della generazione i grafi appena creati.\\
È di fondamentale importanza però specificare che il processo di disegno per grafi di grandi dimensioni è molto dispendioso e dunque può richiedere un tempo considerevole.\\

Come prima operazione all'avvio del programma è disponibile per l'utente una scelta della classe di grafo da generare effettuata attraverso un interfaccia di selezione da console implementata grazie alla libreria Pick.\\

Sono disponibili per l'utente 2 modalità di funzionamento per la generazione, la modalità SINGLE MODE (la modalità di default del programma) e la modalità MULTIPLE MODE (accessibile attraverso la selezione dell'opzione MULTIPLE nella scelta della classe).\\

\subsection{generator.py : SINGLE MODE}
\justify
Le classi implementate fanno riferimento a quelle presenti nella libreria NetworkX, ovvero le seguenti (se ne citano solo alcune).

\begin{itemize}
	\item Classic
	\item Expanders
	\item Small 
	\item Random graphs 
	\item Duplication divergence 
	\item ...
	\item MULTIPLE
\end{itemize}

Una volta selezionata la classe desiderata l'utente si troverà davanti una nuova interfaccia di selezione da console implementata attraverso l'uso del modulo Pick.\\

L'opzione MULTIPLE cambia la tipologia di funzionamento del programma, che da SINGLE MODE (modalità di generazione di un singolo grafo per volta) passa a MULTIPLE MODE (nella quale possono essere generati da 1 a n grafi della stessa tipologia in un solo processo di creazione, con n scelto dall'utente).\\
Concentriamoci ora sulla SINGLE MODE, la default mode del programma.\\

Questa volta l'utente dovrà scegliere la tipologia di grafo da creare.\\
Per ogni classe vi sono molteplici tipologie di grafo che l'utente può scegliere di generare.\\

Le tipologie implementate fanno riferimento a quelle presenti nel modulo NetworkX, in particolare ciascuna tipologia ha un costruttore di libreria corrispondente che provvede a generare le strutture elementari e a comporre l'oggetto matematico richiesto dall'utente.\\

Solo per far comprendere al lettore la vastità delle scelte possibili per l'utente in fase di selezione del grafo da generare, vengono qui si seguito riportate le tipologie di grafi implementate per la sola classe di grafi Classic.

\begin{itemize}
	\item balanced tree
	\item complete graph
	\item circular ladder graph
	\item cycle graph
	\item dorogovtsev goltsev mendes graph
	\item ladder graph
	\item lollipop graph
	\item path graph
	\item star graph
	\item turan graph
	\item wheel graph
	\item ...
\end{itemize}

Una volta selezionata la tipologia di grafo da implementare, l'utente potrà inserire i parametri di creazione per quest'ultimo.\\
I parametri associati ai grafi variano da tipologia a tipologia e sono necessari e fondamentali per la corretta generazione del grafo scelto.\\

Per una migliore comprensione, ad esempio i parametri associati alla tipologia balanced tree sono il branching factor e l'height dell'albero, invece per la tipologia di grafo complete graph vi è un unico parametro da passare al programma, il node number del grafo.\\
L'esempio ovviamente ricopre solo 2 tipologie di grafo, ma ciò vale per ogni tipologia implementata nel programma.\\

A questo punto l'utente è chiamato a scegliere quale tipologia di dato utilizzare per codificare i pesi associati agli archi del grafo, peso flottante (tipo float) o peso intero (tipo int).\\
Possiamo tralasciare il tipo flottante, dato che quest'ultimo, non essendo interessante e significativo per la sperimentazione, è stato tralasciato in favore del tipo intero.\\

L'utente dunque dovrà scegliere i valori massimo e minimo relativi al range all'interno del quale oscilleranno randomicamente i pesi interi associati agli archi del grafo.\\
È possibile scegliere solo pesi interi positivi, ovvero i valori minimo e massimo del range devono essere compresi tra \(0 \geq minimo \geq massimo \geq n\), con \(n\to\infty\).\\

L'utente inoltre dovrà inserire il nome del grafo da creare il quale sarà utilizzato dal programma per creare la sotto porzione di filesystem relativa al grafo generato, ovvero nome-scelto.dir/nomescelto.edgelist, in modo da non creare conflitti tra i dati.\\

A questo punto il programma procederà a scrivere sul filesystem la struttura cartella/file.edgelist relativa al grafo appena creato.\\

Il file nel quale è codificato il grafo generato ha estensione .edgelist (il file .dot come specificato sopra è stato utilizzato solo in fase di debug e quindi non viene considerato nella trattazione).\\

Il file .edgelist è un file di tipo testuale che codifica sotto forma di lista (nodo, nodo, peso) la matrice di adiacenza che descrive il grafo generato.\\
Il file si presenta nella forma qui di seguito (ciascuna coppia (nodo, nodo) codifica un arco al quale viene associato il terzo valore della tupla, ovvero il peso intero).\\

\begin{description}
	\item nodo nodo peso
	\item 0    1    9
	\item 0    2    20
	\item 1    2    15
	\item 2    3    3
	\item ...
\end{description}

I nodi sono generati in modo totalmente dinamico utilizzando valori da 0 a n interi positivi, con n scelto dall'utente in fase di creazione quando richiesto come parametro associato alla tipologia di grafo da generare.\\

Per completezza specifichiamo che la libreria offre i seguenti 4 tipi di grafi.

\begin{itemize}
	\item Graph (grafo senza parallelismo non-orientato)
	\item Directed Graph (grafo senza parallelismo orientato)
	\item MultiGraph (grafo con parallelismo non-orientato)
	\item Directed MultiGraph (grafo con parallelismo orientato)
\end{itemize}

Nel programma è stata implementata solo la tipologia Graph, cioè grafi senza parallelismo non-orientati (con pesi interi positivi associati agli archi e valori interi positivi associati ai nodi) come richiesto dal problema modellato in precedenza, ovvero il gioco della k-colorazione generalizzata.\\

Il programma termina a questo punto l'esecuzione permettendo all'utente di scegliere se disegnare il grafo appena creato attraverso la libreria MatPlotLib, l'utente può saltare l'esecuzione di questa operazione rispondendo negativamente alla richiesta.\\

\subsection{generator.py : MULTIPLE MODE}
\justify
Il funzionamento della modalità MULTIPLE MODE, accessibile selezionando l'opzione MULTIPLE durante la scelta della classe, è quasi del tutto analogo a quello descritto in precedenza, le uniche differenze sono le seguenti.\\

Dopo aver scelto la tipologia di grafo da generare, all'utente verrà chiesto come parametro aggiuntivo il numero di iterazioni relativo all'algoritmo di generazione multipla.\\
In sostanza l'utente dovrà scegliere quanti grafi generare (appartenenti alla tipologia scelta in precedenza).\\

In seguito l'utente dovrà inserire un ulteriore parametro aggiuntivo, ovvero il valore minimo e massimo relativi al range all'interno del quale dovrà oscillare randomicamente il numero di nodi dei grafi da generare.\\
I valori minimo e massimo dovranno ovviamente essere compresi tra \(0 \geq minimo \geq massimo \geq n\), con \(n\to\infty\), come specificato in precedenza.\\

All'utente verrà inoltre chiesto di inserire il nome della cartella nella quale inserire gli output delle generazioni multiple, come nel caso descritto nella sezione SINGLE MODE.\\

A questo punto l'algoritmo di generazione provvederà a creare n grafi (con n scelto dall'utente, come descritto poco sopra) appartenenti alla tipologia scelta (ad esempio complete graph).\\
Ciascun grafo creato avrà un valore randomico di nodi compreso tra \(0 \geq minimo \geq numero di nodi \geq massimo \geq n\).\\

Il programma provverà automaticamente e in modo totalmente dinamico a creare le strutture nel filesystem necessarie a salvare correttamente i file .edgelist relativi a ciascun grafo creato durante la generazione multipla.\\
È stato implementato un processo di assegnamento automatico del nome per ciascun output generato che utilizza il round di iterazione assieme alla tipologia e al numero di nodi del grafo creato, in modo da evitare conflitti, inconsistenza e perdita dei dati.\\

Passiamo ora a descrivere il programma reader.py, il lettore di grafi, nel quale sono includi gli algoritmi per il calcolo degli equilibri di Nash e per il calcolo degli ottimi utilizzando le 2 funzioni di benessere sociale utilitario e egalitario, il vero cuore dell'implementazione.\\


\section{reader.py : il lettore di grafi}
\justify
reader.py









%\section{Analisi e descrizione degli algoritmi}
%\justify
%
%\subsection{nash_equilibrium : l'algoritmo per il calcolo degli equilibri di Nash}
%\justify
%
%\subsection{utilitarian_social_welfare : l'algoritmo per il calcolo dell'ottimo relativo alla funzione di benessere sociale utilitario}
%\justify
%
%\subsection{egalitarian_social_welfare : l'algoritmo per il calcolo dell'ottimo relativo alla funzione di benessere sociale egalitario}
%\justify