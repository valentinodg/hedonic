\chapter{Implementazione}
\justify
In questo capitolo andremo a delineare e descrivere gli aspetti fondamentali ed essenziali relativi all'attività di implementazione. Inizieremo con una presentazione della struttura generale dei programmi assieme ad una descrizione accurata dei componenti utilizzati e delle scelte effettuate in fase di progettazione. In seguito procederemo con un'attenta analisi degli algoritmi implementati, ovvero l'algoritmo per il calcolo degli equilibri di Nash, quello per il calcolo dell'ottimo relativo alla funzione di benessere sociale utilitario e quello per il calcolo dell'ottimo relativo alla funzione di benessere sociale egalitario.\\
Tale sezione sarà caratterizzata dall'utilizzo di pseudocodice per ciascuno degli algoritmi trattati, in modo tale da rendere più comprensibile la descrizione dei cicli e delle operazioni. Tratteremo in modo approfondito questa porzione del documento poiché precede la sezione relativa alla sperimentazione effettuata attraverso i programmi implementati e dunque è di fondamentale importanza.\\

\section{Struttura generale}
\justify
Procediamo presentando la struttura generale relativa programmi implementati. Quest'ultima è rappresentata attraverso una composizione ad albero che riproduce una porzione di filesystem partendo dalla root del progetto. Al fine di rendere più chiara la lettura viene inoltre fornita un breve leggenda sulla nomenclatura utilizzata.

\begin{itemize}
	\item La nomenclatura \textbf{nome.dir} indica che l'oggetto è una cartella
	\item La nomenclatura \textbf{nome.edgelist} indica che l'oggetto è un file con estensione .edgelist (oggetto principale modellato dal programma)
	\item La nomenclatura \textbf{nome.dot} indica che l'oggetto è un file con estensione .dot (oggetto utilizzato su macchine GNU/Linux per il disegno attraverso l'uso della libreria PyGraphViz in fase di debug)
	\item le lettere \textbf{X,K,Y,Z,H,W} rappresentano numeri casuali (sono utilizzate per descrivere la moltitudine di cartelle, grafi creati e risultati ottenuti durante un generale caso d'uso dei programmi)
	\item la nomenclatura \textbf{nome.init} indica che l'oggetto è un file con estensione .init (oggetto utilizzato in fase di lettura per salvare le caratteristiche dei grafi (nodi, archi, pesi, colorazione) e dei colori (colori, profitti))
	\item la nomenclatura \textbf{nome.out} indica che l'oggetto è un file con estensione .out (oggetto utilizzato in fase di lettura per salvare i risultati derivanti da esecuzioni singole o multiple usando gli algoritmi per il calcolo dell'equilibrio di Nash, dell'ottimo con funzione di benessere sociale utilitario e dell'ottimo con funzione di benessere sociale egalitario)
\end{itemize}

Descriviamo ora la funzione basilare di alcuni componenti dell'albero sottostante che rappresenta un esempio generale relativo ad un caso d'uso dei programmi.

\begin{itemize}
	\item La cartella \textbf{generator} contiene al suo interno l'intera struttura relativa al generatore di grafi
	\item La cartella \textbf{gen} contiene i risultati delle generazioni singole di grafi
	\begin{enumerate}
		\item Al suo interno vi sono X cartelle gen-dir-X (il nome viene assegnato durante l'esecuzione dall'utente) generate dinamicamente
		\item Ciascuna cartella contiene il risultato di una generazione singola di un grafo, ciascuna generazione produce una coppia di file .edgelist e .dot (quest'ultimo utilizzato solo in fase di debug)
		\item Ogni gruppo \textit{cartella-file.edgelist-file.dot} rappresenta il risultato di una generazione singola
	\end{enumerate}
	\item La cartella \textbf{m-gen} contiene i risultati delle generazioni multiple di grafi
	\begin{enumerate}
		\item Al suo interno vi sono Y cartelle m-gen-dir-Y (il nome viene assegnato durante l'esecuzione dall'utente) generate dinamicamente
		\item Ciascuna cartella contiene il risultato di una generazione multipla di grafi, ciascuna generazione produce molteplici coppie (nell'esempio K,Z,...) di file .edgelist e .dot (quest'ultimo utilizzato solo in fase di debug)
		\item Ogni gruppo \textit{cartella-file.edgelist-file.dot-file.edgelist-file.dot-...}\\
		rappresenta il risultato di una generazione multipla
	\end{enumerate}
	\item Il file \textbf{generator.py} contiene al suo interno il codice del generatore di grafi scritto interamente in linguaggio Python
\end{itemize}

\begin{itemize}
	\item La cartella \textbf{reader} contiene al suo interno l'intera struttura relativa al lettore di grafi
	\item La cartella \textbf{result} contiene i risultati delle letture / sperimentazioni su grafi singoli
	\begin{enumerate}
		\item Al suo interno vi sono H cartelle result-dir-H (il nome viene preso automaticamente dal grafo in lettura) generate dinamicamente
		\item Ciascuna cartella contiene il singolo risultato di una lettura / sperimentazione su un grafo, ciascun lettura / sperimentazione produce una coppia di file .init e .out
		\item Ogni gruppo \textit{cartella-file.init-file.out} rappresenta il risultato di una singola lettura / sperimentazione 
	\end{enumerate}
	\item La cartella \textbf{m-result} contiene i risultati delle letture / sperimentazioni su grafi multipli
	\begin{enumerate}
		\item Al suo interno vi sono W cartelle m-result-dir-W (il nome viene preso automaticamente dalla cartella relativa alla moltitudine di grafi in lettura) generate dinamicamente
		\item Ciascuna cartella contiene i risultati di letture / sperimentazioni su grafo multipli, l'insieme di tutte le letture / sperimentazioni effettuate produce una coppia di file .init e .out
		\item Ogni gruppo \textit{cartella-file.init-file.out} rappresenta il risultato di una lettura / sperimentazione multipla
	\end{enumerate}
	\item Il file \textbf{reader.py} contiene al suo interno il codice del lettore di grafi scritto interamente in linguaggio Python 
\end{itemize}

\newpage
\dirtree{%
.1 /.
.2 generator.dir.
.3 gen.dir.
.4 gen-dir-1.dir.
.5 graph-1.edgelist.
.5 graph-1.dot.
.4 .....
.4 gen-dir-X.dir.
.5 graph-X.edgelist.
.5 graph-X.dot.
.3 m-gen.dir.
.4 m-gen-dir-1.dir. 
.5 graph-1.edgelist.
.5 graph-1.dot.
.5 .....
.5 graph-K.edgelist.
.5 graph-K.dot.
.4 .....
.4 m-gen-dir-Y.dir.
.5 graph-1.edgelist.
.5 graph-1.dot.
.5 .....
.5 graph-Z.edgelist.
.5 graph-Z.dot.
.3 generator.py.
.2 reader.dir.
.3 result.dir.
.4 result-dir-1.dir.
.5 graph-1.init.
.5 graph-1.out.
.4 .....
.4 result-dir-H.dir.
.5 graph-H.init.
.5 graph-H.out.
.3 m-result.dir.
.4 m-result-dir-1.dir.
.5 graph-1.init.
.5 graph-1.out.
.4 .....
.4 m-result-dir-W.dir.
.5 graph-W.init.
.5 graph-W.out.
}

\section{Componenti utilizzati e progettazione}
\justify
I programmi generator.py e reader.py sono stati interamente scritti utilizzando il linguaggio Python [versione 3.6.5]. Il codice è stato scritto utilizzando differenti editor di testo (vim [neovim], spacemacs, sublime-text, atom,...) e testato su diverse macchine GNU/Linux e Windows, in particolare su differenti shell (bash, zsh, fish) e su cmd. Per agevolare il processo di progettazione e scrittura del codice l'intera struttura del progetto è stata caricata in un repository all'interno del sito github e gestita in remoto (attraverso il software git).\\
Per questioni di compatibilità e versatilità è stata utilizzata in modo massiccio la libreria standard relativa al linguaggio Python per effettuare la quasi totalità delle operazioni in entrambi i programmi. La versione di riferimento della libreria è quella associata alla versione del linguaggio utilizzato, dunque la 3.6.5. Al fine di trascurare alcuni aspetti relativi alla strutturazione e costruzione dei grafi, è stata utilizzata una potente libreria per la creazione e la manipolazione di questi oggetti matematici, ovvero NetworkX. Tale scelta di progettazione ha permesso al sottoscritto di concentrarsi maggiormente sull'implementazione e sull'ottimizzazione degli algoritmi. Inoltre tale scelta ha consentito al sottoscritto di rendere totalmente dinamici i processi di creazione e lettura dei grafi, ciò ha alleggerito di molto il carico di lavoro in fase di sperimentazione.\\
La libreria standard del linguaggio Python è stata utilizzata in particolare per rendere totalmente dinamica e cross-platform la gestione del filesystem. Ciò è stato necessario per garantire il funzionamento asincrono del generatore e del lettore, in modo tale da facilitare il lavoro in fase di sperimentazione. Le fasi di generazione e lettura dei grafi infatti sono state completamente separate al livello di utilizzo, per fare ciò è stato necessario manipolare efficientemente il filesystem in modo da salvare i grafi creati e i risultati delle sperimentazioni su file. Tali operazioni sono perfettamente funzionanti sia su sistemi che rispettano lo standard POSIX (Sistemi Unix-like) per il filesystem sia per sistemi che non lo rispettano (Sistemi Windows), dunque l'intero progetto è totalmente cross-platform e può essere facilmente migrato rendendo la portabilità un importante fattore di forza di quest'ultimo.\\
Il formato principale manipolato dai programmi è il formato .edgelist che analizzeremo in seguito. In fase di debug è stata utilizzata la libreria di disegno MatPlotLib per rappresentare i grafi, quest'ultima è integrata in modo nativo all'interno della libreria NetworkX, dunque tale scelta di utilizzo ha reso più facili le operazioni di analisi e debug. Un'altra libreria che è stata utilizzata in fase di analisi e debug per rappresentare i grafi in ambiente GNU/Linux è la libreria di disegno PyGraphViz. Anche quest'ultima è integrata in modo nativo all'interno della libreria NetworkX. Il formato di descrizione testuale dei grafi .dot è stato utilizzato solo in fase di debug in ambiente GNU/Linux assieme alla libreria di disegno PyGraphViz, dunque possiamo tralasciare la sua definizione e descrizione dato che non viene utilizzato all'interno dei programmi durante l'esecuzione. Altre librerie minori sono state scelte in fase di progettazione ed utilizzate all'interno dei programmi, ad esempio la libreria per la colorazione dell'output testuale su terminal emulators cross-platform Colorama, è stata utilizzata in fase di analisi e debug per semplificare e rendere più chiara la lettura dell'output relativo all'esecuzione degli algoritmi. Un altro esempio è l'utilizzo della libreria cross-platform Pick, che rende semplice ed efficace la selezione delle opzioni all'interno dei terminal emulators durante l'esecuzione dei programmi. L'elenco completo delle librerie utilizzate all'interno dei programmi è il seguente.

\begin{itemize}
	\item Python Standard Library (Python 3.6.5 - Python 2.7.14)\\
	https://docs.python.org/3/library/
	\item NetworkX Library (NetworkX 2.1)\\ 	
	https://pypi.org/project/networkx/	
	\item Matplotlib Library (Matplotlib 2.2)\\
	https://pypi.org/project/matplotlib/
	\item Pick Library (Pick 0.6.4)\\
	https://pypi.org/project/pick/
	\item Pydot Library (Pydot 1.2.4)\\
	https://pypi.org/project/pydot/
	\item Graphviz Library (Graphviz 0.8.2)\\
	https://pypi.org/project/graphviz/
	\item PyParsing Library (PyParsing 2.2.0)\\
	https://pypi.org/project/pyparsing/
	\item Colorama Library (Colorama 0.3.9)\\
	https://pypi.org/project/colorama/
\end{itemize}

Per il funzionamento completo dei programmi è necessaria l'installazione del linguaggio Python e dei suddetti componenti attraverso l'uso del modulo pip e/o l'uso di package manager (apt, pacman, ...).\\
Procediamo ora nella trattazione descrivendo il funzionamento dei programmi generator.py e reader.py. Saranno poi analizzati in modo approfondito gli algoritmi per il calcolo degli equilibri di Nash e degli ottimi.\\

\section{generator.py : il generatore di grafi}
\justify
Il programma generator.py è un generatore dinamico di grafi scritto interamente in Python, in grado di semplificare le operazioni di creazione e manipolazione di questi oggetti matematici e in grado di creare automaticamente tutte le strutture di filesystem necessarie al salvataggio su file dei grafi generati. Il programma, come specificato in precedenza, è completamente cross-platform e, per ciò che riguarda la gestione del filesystem, è stato accuratamente ottimizzato per non generare conflitti e problemi di inconsistenza dei dati. Principalmente il programma utilizza due moduli principali necessari al corretto funzionamento dello stesso, la Standard Library del linguaggio Python per le funzioni di base e la libreria NetworkX per la creazione e manipolazione dei grafi. Di seguito vengono riportate le caratteristiche del programma assieme ad un esempio generale di un caso d'uso.\\
Per prima cosa vengono impostati i motori di disegno, ovvero le librerie MatPlotLib e PyGraphViz. Quest'ultima è stata utilizzata solo in ambiente GNU/Linux in fase di debug, dunque non è disponibile per l'utente. In compenso è però disponibile per l'utente la libreria MatPlotLib che consente a quest'ultimo, qualora volesse, di disegnare, al termine della generazione, i grafi appena creati. È di fondamentale importanza però specificare che il processo di disegno per grafi di grandi dimensioni è molto pesante e dunque può richiedere un tempo considerevole.\\
Come prima operazione, all'avvio del programma, è disponibile per l'utente una scelta della classe di grafo da generare effettuata attraverso un'interfaccia di selezione da console implementata grazie alla libreria Pick. Sono disponibili per l'utente 2 modalità di funzionamento per la generazione, la modalità SINGLE MODE (la modalità di default del programma) e la modalità MULTIPLE MODE (accessibile attraverso la selezione dell'opzione MULTIPLE nella scelta della classe).\\

\subsection{generator.py : SINGLE MODE}
\justify
Le classi implementate fanno riferimento a quelle presenti nella libreria NetworkX, ovvero le seguenti (se ne citano solo alcune).

\begin{itemize}
	\item Classic
	\item Expanders
	\item Small 
	\item Random graphs 
	\item Duplication divergence 
	\item ...
	\item MULTIPLE
\end{itemize}

Una volta selezionata la classe desiderata, l'utente si troverà davanti una nuova interfaccia di selezione da console implementata attraverso l'uso del modulo Pick. La selezione dell'opzione MULTIPLE cambia la tipologia di funzionamento del programma, che da SINGLE MODE (modalità di generazione di un singolo grafo per volta) passa a MULTIPLE MODE (nella quale possono essere generati da 1 a n grafi della stessa tipologia in un unico processo di creazione, con n scelto dall'utente).\\
Concentriamoci ora sulla creazione in SINGLE MODE, ovvero la la modalità di default del programma. Questa volta l'utente dovrà scegliere la tipologia di grafo da creare. Per ogni classe vi sono molteplici tipologie di grafo che l'utente può scegliere di generare. Le tipologie implementate fanno riferimento a quelle presenti nel modulo NetworkX, in particolare ciascuna tipologia ha un costruttore di libreria corrispondente che provvede a generare le strutture elementari e a comporre l'oggetto matematico richiesto dall'utente. Solo per far comprendere al lettore la vastità delle scelte possibili per l'utente in fase di selezione del grafo da generare, vengono qui si seguito riportate le tipologie di grafi implementate per la sola classe \textit{Classic}.

\begin{itemize}
	\item balanced tree
	\item complete graph
	\item circular ladder graph
	\item cycle graph
	\item dorogovtsev goltsev mendes graph
	\item ladder graph
	\item lollipop graph
	\item path graph
	\item star graph
	\item turan graph
	\item wheel graph
	\item ...
\end{itemize}

Una volta selezionata la tipologia di grafo da implementare, l'utente potrà inserire i parametri di creazione per quest'ultimo. I parametri associati ai grafi variano da tipologia a tipologia e sono necessari e fondamentali per la corretta generazione del grafo scelto. Per una migliore comprensione, ad esempio, i parametri associati alla tipologia \textit{balanced\_tree} sono il \textit{branching\_factor} e l'\textit{height} dell'albero, invece per la tipologia di grafo \textit{complete\_graph} vi è un unico parametro da passare al programma, il \textit{node\_number} del grafo. L'esempio ovviamente ricopre solo 2 tipologie di grafo, ma ciò vale per ogni tipologia implementata nel programma.\\
A questo punto l'utente è chiamato a scegliere quale tipologia di dato utilizzare per codificare i pesi associati agli archi del grafo, peso flottante (tipo float) o peso intero (tipo int). Possiamo trascurare il tipo flottante, dato che quest'ultimo, non essendo interessante e significativo per la sperimentazione, è stato tralasciato in favore del tipo intero.\\
L'utente dunque dovrà scegliere i valori massimo e minimo relativi al range all'interno del quale oscilleranno randomicamente i pesi interi associati agli archi del grafo. È possibile scegliere solo pesi interi positivi, ovvero, i valori minimo e massimo del range, devono essere compresi tra \(0 \geq minimo \geq massimo \geq n\), con \(n\to\infty\).\\
L'utente inoltre dovrà inserire il nome del grafo da creare che sarà utilizzato dal programma per costruire la sotto porzione di filesystem relativa al grafo generato, ovvero \textit{nome-scelto.dir/nome-scelto.edgelist}, in modo da non creare conflitti tra i dati. A questo punto il programma procederà a scrivere sul filesystem la struttura \textit{cartella/file.edgelist} relativa al grafo appena creato.\\
Il file, nel quale è codificato il grafo generato, ha estensione .edgelist (il file .dot, come specificato sopra, è stato utilizzato solo in fase di debug e quindi non viene considerato nella trattazione). Il file .edgelist è un file di tipo testuale che codifica, sotto forma di lista (nodo, nodo, peso), la matrice di adiacenza che descrive il grafo generato. I nodi sono generati in modo totalmente dinamico utilizzando valori interi positivi da $0$ a $n$, con $n$ scelto dall'utente in fase di creazione quando richiesto come parametro associato alla tipologia di grafo da generare. Il file si presenta nella forma qui di seguito indicata, ciascuna coppia (nodo, nodo) codifica un arco al quale viene associato un peso attraverso la definizione del terzo valore della tupla, ovvero il peso intero).

\begin{table}[H]
\centering
\begin{tabular}{ccc}
\textbf{nodo} & \textbf{nodo} & \textbf{peso} \\
0 & 1 & 9 \\
0 & 2 & 20 \\
1 & 2 & 15 \\
2 & 3 & 3 \\
... & ... & ...
\end{tabular}
\end{table}

Per completezza specifichiamo che la libreria offre i seguenti 4 tipi di grafi.

\begin{itemize}
	\item Graph (grafo senza parallelismo non-orientato)
	\item Directed Graph (grafo senza parallelismo orientato)
	\item MultiGraph (grafo con parallelismo non-orientato)
	\item Directed MultiGraph (grafo con parallelismo orientato)
\end{itemize}

Nel programma è stata implementata solo la tipologia Graph, cioè grafi senza parallelismo non-orientati (con pesi interi positivi associati agli archi e valori interi positivi associati ai nodi) come richiesto dal problema modellato in precedenza, ovvero il gioco della \(k\)-colorazione generalizzata. Il programma termina a questo punto l'esecuzione permettendo all'utente di scegliere se disegnare il grafo appena creato attraverso la libreria MatPlotLib, l'utente può saltare l'esecuzione di questa operazione rispondendo negativamente alla richiesta.\\

\subsection{generator.py : MULTIPLE MODE}
\justify
Il funzionamento della modalità MULTIPLE MODE, accessibile selezionando l'opzione MULTIPLE durante la scelta della classe, è quasi del tutto analogo a quello descritto in precedenza, le uniche differenze sono le seguenti. Dopo aver scelto la tipologia di grafo da generare, all'utente verrà chiesto di inserire, come parametro aggiuntivo, il numero di iterazioni relativo all'algoritmo di generazione multipla. In sostanza l'utente dovrà scegliere quanti grafi generare (appartenenti alla tipologia selezionata in precedenza). In seguito l'utente dovrà inserire un ulteriore parametro aggiuntivo, ovvero i valori minimo e massimo relativi al range all'interno del quale dovrà oscillare randomicamente il numero di nodi dei grafi da generare. I valori minimo e massimo dovranno ovviamente essere compresi tra \(0 \geq minimo \geq massimo \geq n\), con \(n\to\infty\), come specificato in precedenza. All'utente verrà inoltre chiesto di inserire il nome della cartella nella quale salvare gli output delle generazioni multiple, come nel caso descritto nella sezione SINGLE MODE. A questo punto l'algoritmo di generazione provvederà a creare \(n\) grafi (con \(n\) scelto dall'utente, come descritto poco sopra) appartenenti alla tipologia selezionata (ad esempio \textit{complete graph}). Ciascun grafo creato avrà un valore randomico di nodi compreso tra \(0 \geq minimo \geq numero\_di\_nodi \geq massimo \geq n\). Il programma provvederà automaticamente e in modo totalmente dinamico a creare le strutture nel filesystem necessarie a salvare correttamente i file .edgelist relativi a ciascun grafo creato durante la generazione multipla. È stato implementato un processo di assegnamento automatico del nome per ciascun output generato che utilizza il round di iterazione assieme alla tipologia e al numero di nodi del grafo creato, così da evitare conflitti, inconsistenza e perdita dei dati.\\
Passiamo ora a descrivere il programma reader.py, il lettore di grafi, nel quale sono inclusi gli algoritmi per il calcolo degli equilibri di Nash e per il calcolo degli ottimi utilizzando le 2 funzioni di benessere sociale utilitario e egalitario, che rappresentano il vero cuore dell'implementazione.\\

\section{reader.py : il lettore di grafi}
\justify
il programma reader.py è un lettore dinamico di grafi, anche esso scritto interamente in linguaggio Python, che consente la lettura e la manipolazione dei grafi creati in modo asincrono attraverso l'utilizzo del generatore generator.py. Inoltre il programma consente la modellazione del problema del gioco della \(k\)-colorazione generalizzata attraverso un massiccio uso della Standard Library del linguaggio Python. Nel programma reader.py sono incluse le definizioni degli algoritmi per il calcolo degli equilibri di Nash e quelle per il calcolo degli ottimi con funzioni di benessere utilitario e egalitario. Il programma permette la lettura di un singolo o di molteplici grafi per volta e consente l'esecuzione dei suddetti algoritmi sulle istanze lette. Per rendere meno faticoso il lavoro relativo alla sperimentazione, il programma è in grado di raccogliere efficacemente e organizzare i dati derivanti dalle esecuzioni in tempo reale. In modo totalmente dinamico, il lettore è in grado di salvare i risultati delle sperimentazioni manipolando le strutture relative al filesystem. Come per il generatore, il programma utilizza principalmente e in modo quasi esclusivo la libreria standard del linguaggio Python per eseguire queste operazioni. Anche in questo caso, le primitive e le funzioni utilizzate garantiscono il funzionamento cross-platform e dunque la portabilità del programma. Il tutto è stato ampiamente testato su macchine con sistema POSIX e non, il programma è totalmente ottimizzato e funzionale in questo senso.\\
I file di output, per ciascuna esecuzione, sono 2, il file .init (file testuale che contiene il salvataggio delle informazioni basilari del grafo, creato dopo aver effettuato la modellazione del gioco in oggetto) e il file.out (file testuale che contiene i risultati finali derivanti dall'esecuzione di uno o più algoritmi). Sia per le esecuzioni singole che per quelle multiple, il risultato prodotto sarà sempre e comunque una coppia file.init / file.out. Anche in questo caso, sono disponibili per l'utente i moduli per il disegno dei grafi, in particolare pre e post modellazione e per rappresentare i risultati delle esecuzioni (ad esempio la colorazione iniziale e la colorazione stabile ottenute dal calcolo di un equilibrio di Nash). La principale libreria in questo senso è MatPlotLib (la libreria PyGraphViz è stata utilizzata solo in fase di debug come specificato in precedenza).\\
Per non tediare il lettore, confermiamo che, anche il programma reader.py, fa uso delle medesime librerie addizionali utilizzate nel programma generator.py, il loro uso è però marginale e dunque non verranno trattate, come in precedenza. L'utilizzo più intensivo è relativo alla libreria Pick, usata per fornire un'interfaccia di selezione da console per l'utente, e alla libreria Colorama, utilizzata in fase di lettura e debug per colorare l'output su console e mettere in risalto i dati fondamentali relativi alle esecuzioni degli algoritmi e alle operazioni essenziali di gestione del programma. Di fondamentale importanza è l'utilizzo della libreria NetworkX che consente la lettura e l'interpretazione delle informazioni relative ai file testuali di creazione .edgelist e la ricostruzione, in modo asincrono, dei grafi generati in precedenza, in modo da utilizzarli per la sperimentazione.\\
Anche in questo caso, qui di seguito, vengono riportate le caratteristiche del programma assieme ad un esempio generale di un caso d'uso in modo da descrivere il funzionamento di quest'ultimo e le operazioni disponibili per l'utente. Sono disponibili per l'utente, in modo speculare e simmetrico rispetto alla definizione del programma generator.py, 2 modalità di funzionamento per la lettura e l'esecuzione : la modalità SINGLE EXEC e la modalità MULTIPLE EXEC. All'avvio del programma l'utente dovrà scegliere una delle 2 modalità d'uso attraverso un'interfaccia di selezione da console implementata attraverso l'utilizzo della libreria Pick.\\

\subsection{reader.py : SINGLE EXEC}
\justify
In modalità SINGLE EXEC, il programma effettuerà una ricerca globale automatica e dinamica dei file con estensione .edgelist all'interno della cartella gen, la directory relativa alle generazioni di grafi singoli creata dal generatore generator.py in modalità SINGLE MODE. A questo punto l'utente dovrà selezione il grafo da modellare e sul quale eseguire una sperimentazione, utilizzando gli algoritmi forniti all'interno del programma. La scelta è implementata attraverso un'interfaccia di selezione creata con la libreria Pick nella quale apparirà la lista di file .edgelist trovati. Il programma leggerà e interpreterà il contenuto del file.edgelist relativo al grafo selezionato dall'utente e attraverso le funzioni della libreria NetworkX ricostruirà l'istanza dell'oggetto matematico desiderato, creato in precedenza e sul quale si vuole iniziare una sperimentazione. Ovviamente l'operazione genererà sempre e comunque un'istanza di grafo senza parallelismo non-orientato, con valori interi positivi associati ai nodi e pesi interi positivi associati agli archi (parametri scelti in precedenza, durante la fase di creazione del grafo e ricostruiti dalle funzioni di libreria). In seguito l'utente sarà nuovamente chiamato a scegliere 2 parametri fondamentali per la modellazione del problema, ovvero il numero di colori e valore massimo per il profitto associato a questi ultimi.\\
L'utente potrà scegliere il numero massimo di colori presenti all'interno dell'istanza che si sta modellando. Il numero massimo di colori non può essere superiore al numero di nodi del grafo, altrimenti la sperimentazione perderebbe di senso e in più non verrebbe rispettata la definizione del problema presentata nel Capitolo 2. I colori, come ogni altro parametro del quale non è richiesto un range (valore minimo e massimo), saranno numerati da $0$ a \(n\) (valori interi positivi), con \(n\) scelto dall'utente e sempre \(n \leq numero\_di\_nodi\_del\_grafo\). Come struttura dati, è stata scelta la lista poiché l'elenco dei colori non necessità di essere manipolato in maniera complessa, non vi è inoltre l'esigenza di effettuare query di ricerca indicizzate e altre operazioni poco efficaci sulle liste. Semplicemente la lista dei colori andrà iterata più volte e in modo innestato durante i vari cicli degli algoritmi implementati. Per la creazione è stata utilizzata la potente list comprehension interna al linguaggio Python.\\
L'utente inoltre potrà scegliere il valore massimo all'interno del quale oscilleranno randomicamente i profitti associati ai colori per ciascun giocatore. In questo caso non vi sono restrizioni, scelto \(n\), i valori oscilleranno in modo randomico tra $0$ e \(n\) (valori interi positivi). I profitti legati ai colori, per definizione del modello, potranno essere differenti da giocatore a giocatore, ad esempio il giocatore 0 avrà un profitto di 56 per il colore 0, il giocatore 1 avrà un profitto di 29 per il colore 0 (i valori sono totalmente casuali e servono solo da esempio). Proprio per questo motivo, la struttura dati implementata per soddisfare le caratteristiche del modello, è un doppio dizionario innestato. Assieme alla struttura relativa alle coppie arco-peso e quella relativa all'associazione nodo-colore, che presenteremo in seguito, quest'ultima rappresenta uno dei componenti più utilizzati del programma. È necessaria dunque, in questo caso, un'implementazione che permetta l'utilizzo di query di ricerca asincrone a doppia chiave (l'operazione più pesante che interessa questa struttura). È stata utilizzata a questo scopo la potente nested dictionary comprehension del linguaggio Python, in modo da eliminare la possibilità di conflitto e inconsistenza dei dati, in modo da disambiguare efficacemente le entry del dizionario e dunque in modo da garantire l'utilizzo di interrogazioni ad accesso diretto utili nel programma. È stata generata la seguente struttura (esempio).

\begin{table}[H]
\centering
\begin{tabular}{llllll}
\multicolumn{1}{c}{nodo 0 ::} & \multicolumn{1}{c}{colore 0 :} & \multicolumn{1}{c}{profitto 24,} & \multicolumn{1}{c}{colore 1 :} & \multicolumn{1}{c}{profitto 38,} & \multicolumn{1}{c}{...} \\
nodo 1 :: & colore 0 : & profitto 11, & colore 1 : & profitto 55, & ... \\
nodo 2 :: & colore 0 : & profitto 14, & colore 1 : & profitto 65, & ... \\
nodo 3 :: & colore 0 : & profitto 99, & colore 1 : & profitto 66, & ... \\
\multicolumn{1}{c}{...} & \multicolumn{1}{c}{...} & \multicolumn{1}{c}{...} & \multicolumn{1}{c}{...} & \multicolumn{1}{c}{...} & \multicolumn{1}{c}{...}
\end{tabular}
\end{table}

A questo punto viene generata automaticamente e in modo totalmente randomico la colorazione iniziale per il grafo corrente. Il colore è stato gestito attraverso l'implementazione di dizionari. Ad ogni nodo viene associata una singola entry \textit{chiave : valore} che rappresenta una label. La chiave indica il nome del parametro, ovvero, nel nostro caso, la stringa "color" e il valore indica il colore con il quale è colorato in nodo. Le etichette sono gestite a livello di libreria NetworkX, di conseguenza è stato utilizzato lo standard esplicato all'interno della documentazione. È dunque possibile accedere e manipolare, con facilità e alta velocità computazionale, i dati all'interno dei dizionari che rappresentano i parametri associati al nodo attraverso semplici query ad accesso diretto e a singola chiave, ovvero, nel nostro caso, il parametro "color". Un esempio di colorazione iniziale è presentata qui di seguito.

\begin{table}[H]
\centering
\begin{tabular}{cc}
nodo 0 & colore 2 \\
nodo 1 & colore 1 \\
nodo 2 & colore 1 \\
nodo 3 & colore 0 \\
nodo 4 & colore 2 \\
... & ...
\end{tabular}
\end{table}

Tutti i dati relativi alla modellazione iniziale dell'istanza letta per ricreare le condizioni di partenza del nostro gioco, sono salvate nel file.init correlato all'esecuzione corrente. Specifichiamo nuovamente l'assoluta gestione cross-platform del filesystem e l'efficiente ottimizzazione eseguita sul lato input / output, il tutto è affiancato ovviamente da numerosissimi test su diverse tipologie di macchine. Nel file testuale .init, relativo all'esecuzione, vengono inseriti i seguenti parametri.

\begin{itemize}
	\item lista dei colori
	\item colorazione iniziale del grafo
	\item numero di nodi del grafo
	\item profitti associati ai colori per ogni giocatore
	\item lista degli archi del grafo con pesi associati
	\item numero degli archi del grafo
\end{itemize}

È importante specificare che il peso degli archi è gestito in modo del tutto identico a quello relativo al colore dei nodi. Infatti il peso degli archi (e gli eventuali altri parametri implementabili in modo nativo grazie alla libreria NetworkX) si presenta come un dizionario \textit{chiave : valore}, nel quale la chiave corrisponde al nome del parametro, ovvero, nel nostro caso, la stringa "weight" e il valore rappresenta il vero e proprio peso associato all'arco. Anche qui dunque, una struttura dati di questo tipo, permette un'alta velocità di calcolo e recupero delle informazioni con query ad accesso diretto a chiave singola, ovvero il nome del parametro richiesto associato all'arco che, nel nostro caso, è la stringa "weight". La struttura dati si presenta come segue (esempio).

\begin{table}[H]
\centering
\begin{tabular}{ccc}
nodo 0 & nodo 1 & weight : 34 \\
nodo 1 & nodo 2 & weight : 55 \\
nodo 2 & nodo 5 & weight : 5 \\
nodo 3 & nodo 2 & weight : 23 \\
... & ... & ...
\end{tabular}
\end{table}

Terminata la creazione del file testuale con estensione .init, il programma procede e genera tutte le strutture del filesystem necessarie a salvare correttamente i risultati della sperimentazione corrente. In particolare crea una nuova cartella all'interno della directory result (poiché siamo in modalità SINGLE EXEC) in modo dinamico prendendo il nome del grafo corrente importato dall'utente. Assegna il medesimo nome al file .init (e al file .out che vedremo tra poco) che viene creato all'interno del path appena generato. A questo punto l'utente viene chiamato a compiere un'ennesima scelta, l'ultima relativa al flusso di esecuzione corrente. All'utente viene chiesto di scegliere 1 fra le 3 opzioni di calcolo disponibili, ciascuna corrispondete a 1 dei 3 algoritmi implementati.

\begin{itemize}
	\item calcolo della colorazione ottima (ottimo con funzione di benessere sociale utilitaria)
	\item calcolo della colorazione ottima (ottimo con funzione di benessere sociale egalitaria)
	\item calcolo della colorazione stabile (equilibrio di Nash)
	\item esecuzione completa
	\item esci
\end{itemize}

Vi è inoltre un'ulteriore opzione ("esci") che consente all'utente di uscire dal programma prima di un'eventuale esecuzione che potrebbe essere pesante a livello di calcolo e dunque dispendiosa al livello temporale, soprattutto per ciò che concerne il calcolo degli ottimi.\\
Per l'utente che esegue in modalità SINGLE EXEC, questo punto del programma rappresenta un hub di esecuzione. L'utente infatti può eseguire, quante volte vuole, i vari algoritmi (può anche eseguirli tutti sull'istanza corrente o uscire e non fare nulla come specificato poco sopra). Terminata l'esecuzione di uno degli algoritmi, all'utente verrà lasciato il pieno controllo. Quest'ultimo potrà leggere il risultato dell'esecuzione da console, analizzare i vari cicli eseguiti e poi tornare all'hub nel quale potrà avviare una nuova esecuzione o uscire dal programma.\\
Vi è inoltre l'opzione "esecuzione completa" che permette di calcolare l'ottimo con funzione di benessere sociale utilitaria, l'ottimo con funzione di benessere sociale egalitario e infine la colorazione stabile, nell'ordine specificato. Il tutto sarà eseguito in modo automatico e slegato dunque dal controllo dell'utente, il quale dovrà fornire solo i classici parametri per la modellazione dell'istanza corrente come il numero di colori o il massimo valore del range relativo ai profitti. Prima di affrontare la descrizione degli algoritmi, il vero cuore dell'implementazione, analizziamo al modalità di funzionamento MULTIPLE EXEC relativa al programma reader.py.\\

\subsection{reader.py : MULTIPLE EXEC}
\justify
Per non tediare il lettore, possiamo specificare che la modalità MULTIPLE EXEC esegue le medesime operazioni di preparazione e modellazione delle varie istanze e salva il risultato di tale operazione in un file testuale estensione .init. Una prima differenza sostanziale è relativa al path in cui vengono cercati i file .edgelist nella fase di scelta della modalità di esecuzione del lettore. Scegliendo MULTIPLE EXEC il programma effettuerà una ricerca globale di tutte le cartelle presenti all'interno della directory mgen, ovvero la cartella contenente tutti i risultati delle varie generazioni multiple, creata dinamicamente dal generatore di grafi in modalità MULTIPLE MODE. A questo punto l'utente sarà nuovamente interpellato e attraverso un'interfaccia di selezione da console dovrà selezionare la cartella contenente i grafi sui quali desidera fare sperimentazione. Una volta selezionata la cartella, il programma utilizzerà tutti i file con estensione .edgelist come istanze dell'esecuzione multipla corrente. In particolare il programma si sviluppa all'interno di un ciclo principale che scorre tutti i file con estensione .edgelist presenti nella cartella scelta dall'utente. Il ciclo prende un grafo alla volta, opera la fase di pre-esecuzione modellando l'istanza corrente secondo la definizione del problema e poi esegue l'algoritmo per il calcolo della colorazione stabile trovando l'equilibrio di Nash per l'istanza corrente. Il ciclo e l'esecuzione, che potrebbe coinvolgere un numero molto grande di grafi, avvengono in maniera totalmente automatica e dunque l'utente può disinteressarsi del programma poiché slegato dal flusso di esecuzione.\\
Proprio a causa del fatto che le istanze potrebbero essere numerose e che la grandezza di ciascuna istanza, in termini di numero di nodi, potrebbe essere elevata, si utilizza come sperimentazione, annessa alla modalità di esecuzione multipla, il solo algoritmo per il calcolo della colorazione stabile (equilibrio di Nash) che vedremo in seguito. L'utente in questa fase che precede l'esecuzione, solo per la prima iterazione, dovrà inserire il valore massimo del range all'interno del quale oscilleranno randomicamente i profitti associati ai colori per ogni giocatore. Per ciò che riguarda il profitto, possiamo affermare che il funzionamento è identico a quello della modalità SINGLE EXEC, ovvero l'utente fornirà un numero \(n\) e il profitto da associare a ciascun colore per ciascun giocatore sarà un valore randomico tra $0$ e \(n\) (valori interi positivi). Per ciò che riguarda il numero dei colori, in modalità MULTIPLE EXEC, il funzionamento è in parte differente. Il numero di colori, infatti, viene definito in modo randomico e dinamico durante l'esecuzione su ciascuna istanza in input. Quest'ultimo sarà un valore intero positivo \(k\) compreso tra \(0 \geq k \geq n\), con \(n=numero\_di\_nodi\_dell'istanza\_corrente\), assegnato randomicamente dal programma.\\
A questo punto il programma inizierà l'esecuzione dell'algoritmo per il calcolo della colorazione stabile per ciascun grafo appartenente all'istanza corrente di esecuzione in modalità MULTIPLE EXEC. La modellazione e le informazioni fondamentali di ciascun grafo saranno salvate in modo congiunto all'interno di un unico file con estensione .init, accuratamente formattate. Lo stesso vale per gli output delle varie esecuzioni, anche in questo caso il file, in formato .out, sarà unico.\\

\section{Analisi e descrizione degli algoritmi}
\justify

Procediamo ora a descrivere i vari algoritmi implementati e ad analizzare approfonditamente le iterazioni e le operazioni di manipolazione effettuate, in modo da definire e delineare al meglio, anche con l'utilizzo di pseudocodice annesso alla trattazione, il funzionamento di questi ultimi. Gli algoritmi implementati sono i seguenti.

\begin{itemize}
	\item L'algoritmo per il calcolo di una colorazione stabile (equilibrio di Nash) con annesse le funzioni di calcolo del benessere sociale utilitario ed egalitario per la colorazione finale stabile trovata.
	\item L'algoritmo per il calcolo della colorazione ottima utilizzando la funzione di benessere sociale utilitario 
	\item L'algoritmo per il calcolo della colorazione ottima utilizzando la funzione di benessere sociale egalitario 
\end{itemize}

\newpage
\subsection{nash\_equilibrium : l'algoritmo per il calcolo degli equilibri di Nash}
\justify
Gli algoritmi analizzati presentano la definizione della variabile $limit$. Quest'ultima contiene il valore del limitatore temporale (in secondi) associato all'esecuzione corrente. Viene impostato in modo dinamico all'inizio dell'esecuzione ed è valido per ogni tipo di calcolo.\\
Il seguente algoritmo viene usato per calcolare una colorazione stabile per il gioco della \(k\)-colorazione generalizzata modellato in precedenza, utilizzando la definizione di equilibrio di Nash. Come abbiamo visto esiste sempre almeno un equilibrio di Nash per ogni istanza di gioco della \(k\)-colorazione generalizzata e il problema di trovare una di queste colorazioni stabili è PLS-Completo. Presentiamo ora lo pseudocodice relativo al suddetto algoritmo e di seguito analizziamo in modo accurato le caratteristiche, le iterazioni e le operazioni eseguite nell'implementazione raggiunta. Si specifica che il seguente algoritmo è stato scritto utilizzando la Standard Library del Python e la libreria di costruzione e manipolazione di grafi NetworkX e che l'implementazione è stata accuratamente ottimizzata nei cicli e nelle operazioni grazie ad un attento uso di funzioni e strutture dati e dunque la computazione è particolarmente snella è rapida.

\newpage
\begin{algorithmic}

\State $start\gets time.time()$
\State $limit\gets X$ \Comment X assegnato dinamicamente dall'utente
\State $time\_limit\gets False$ \\

\State $count\gets 0$
\State $restart\gets True$
\State $last\_improved\_node\gets None$\\

\While{$restart$}
	\If{$time.time() > start + limit$}
		\State $time\_limit\gets True$ 
		\State \textbf{break}
	\EndIf
	\State $restart\gets False$
	\For{$(node,data) \in G.nodes(data=True)$}
		\State $color\_init\gets data['color']$
		\State $color\_best\gets data['color']$
		\State $profit\_old\gets profits[node][data['color']]$
		\If{$node = last\_improved\_node$}
			\State \textbf{continue}
		\EndIf
		\State $neighbors\gets G.neighbors(node)$
		\For{$neighbor \in neighbors$}
			\If{$G.node[neighbor]['color'] \neq G.node[node]['color']$}
				\State $edge\_weight\gets G[node][neighbor]['weight']$
				\State $profit\_old += edge\_weight$
			\Else
				\State \textbf{continue}
			\EndIf
		\EndFor
		\For{$current\_color \in colors$}
			\If{$current\_color \neq color\_init$}
				\State $data['color']\gets current\_color$
				\State $color\_new\gets current\_color$
				\State $profit\_new\gets profits[node][current\_color]$
				\State $neighbors\gets G.neighbors(node)$
				\For{$neighbor \in neighbors$}
					\If{$G.node[neighbor]['color'] \neq G.node[node]['color']$}
						\State $edge\_weight\gets G[node][neighbor]['weight']$
						\State $profit\_new += edge\_weight$
					\Else
						\State \textbf{continue}
					\EndIf
					\If{$profit\_new > profit\_old$}
						\State $profit\_old\gets profit\_new$
						\State $color\_best\gets current\_color$
					\Else
						\State \textbf{continue}
					\EndIf
				\EndFor
			\Else
				\State \textbf{continue}
			\EndIf
		\EndFor
		\State $data['color']\gets color\_best$
		\If{$data['color'] \neq color\_init$}
			\State $count += 1$
			\State $restart\gets True$
			\State $last\_improved\_node\gets node$
			\State \textbf{break}
		\EndIf
	\EndFor
\EndWhile \\

\If{$time\_limit == False$}
	\State $egalitarian\_social\_welfare\gets 0$
	\State $utilitarian\_social\_welfare\gets 0$
	\State $first\_iter\_check\gets True$ \\

	\For{$(node,data) \in G.nodes(data=True)$}
		\State $temp\_egalitarian\_social\_welfare\gets 0$
		\State $temp\_egalitarian\_social\_welfare += profits[node][data['color']]$
		\State $utilitarian\_social\_welfare += profits[node][data['color']]$
		\State $neighbors\gets G.neighbors(node)$
		\For{$neighbor \in neighbors$}
			\If{$G.node[neighbor]['color'] \neq G.node[node]['color']$}
				\State $edge\_weight\gets G[node][neighbor]['weight']$
				\State $utilitarian\_social\_welfare += edge\_weight$
				\State $temp\_egalitarian\_social\_welfare += edge\_weight$
			\Else
				\State \textbf{continue}
			\EndIf
			\If{$first\_iter\_check$}
				\State $egalitarian\_social\_welfare\gets temp\_egalitarian\_social\_welfare$
				\State $first\_iter\_check\gets False$
				\State \textbf{continue}
			\EndIf
			\If{$temp\_egalitarian\_social\_welfare < egalitarian\_social\_welfare$}
				\State $egalitarian\_social\_welfare\gets temp\_egalitarian\_social\_welfare$
			\Else
				\State \textbf{continue}
			\EndIf
		\EndFor
	\EndFor \\

	\State $nash\_utilitarian\_social\_welfare\gets utilitarian\_social\_welfare$
	\State $nash\_egalitarian\_social\_welfare\gets egalitarian\_social\_welfare$ \\

	\If{$check\_utilitarian\_social\_welfare$}
		\State $utilitarian\_price\_of\_anarchy\gets$ \\
		$opt\_utilitarian\_social\_welfare / nash\_utilitarian\_social\_welfare$
	\EndIf
	\If{$check\_egalitarian\_social\_welfare$}
		\State $egalitarian\_price\_of\_anarchy\gets$ \\
		$opt\_egalitarian\_social\_welfare / nash\_egalitarian\_social\_welfare$
	\EndIf \\
\EndIf 

\end{algorithmic}

\newpage
La sintassi dello pseudocodice, in generale nell'aspetto e in particolare in alcuni punti nei quali trascende l'astrazione, è volutamente molto vicina a quella del linguaggio Python in modo tale da coinvolgere il lettore nell'implementazione e in modo da mostrare alcune soluzioni adottate per effettuare le operazioni più significative. In ogni caso le parti più vicine all'implementazione in linguaggio Python saranno abbondantemente spiegate e rese chiare qui di seguito. Sono state omesse nello pseudocodice tutte le porzioni di stampa su console e su file.out dei dati significativi, poiché trascurabili.\\
Il seguente algoritmo viene utilizzato, seguendo la definizione presentata poco sopra, solo nella modalità SINGLE EXEC, in modalità MULTIPLE EXEC non viene considerata l'ultima porzione del codice, ovvero quella relativa al calcolo del prezzo dell'anarchia sperimentale utilitario e egalitario poiché, data la grandezza dei grafi utilizzati in questo tipo di sperimentazione, vengono tralasciati i calcoli dell'ottimo con funzione di benessere sociale utilitario e egalitario. Il prezzo dell'anarchia sperimentale rappresenta lo studio e l'analisi del prezzo dell'anarchia (benessere sociale utilitario - egalitario della colorazione ottima / benessere sociale utilitario - egalitario della colorazione stabile) ma nel caso medio, laddove il prezzo dell'anarchia rappresenta lo studio e l'analisi nel caso peggiore. Il prezzo dell'anarchia sperimentale è uno dei risultati fondamentali prodotti dalla sperimentazione.\\
L'algoritmo presenta 3 importanti porzioni di ottimizzazione dei cicli che verranno presentate qui di seguito, grazie alle quali è possibile snellire la fase di calcolo e diminuire l'impiego di risorse e il tempo di esecuzione. Le strategie di ottimizzazione utilizzate mirano a minimizzare il valore relativo ai passi totali compiuti dall'algoritmo durante la ricerca della dinamica di miglioramento.\\
Come prima operazione impostiamo i valori temporali. In particolare viene memorizzato il tempo corrente relativo all'inizio dell'esecuzione all'interno della variabile $start$, utilizzando la libreria standard del linguaggio Python per effettuare l'operazione. In seguito viene impostato il limite temporale nella variabile $limit$, assegnato dinamicamente dall'utente all'inizio del programma. Oltrepassato il limite temporale interrompiamo l'esecuzione e non restituiamo alcun risultato, poiché quest'ultimo non è stato trovato dall'algoritmo nel tempo prestabilito. Tale controllo viene effettuato inizializzando al valore $False$ la variabile $time\_limit$ ed effettuando ad ogni iterazione il controllo sulla validità del tempo complessivo trascorso, lo analizzeremo tra poco. All'inizio del programma la variabile $count$ viene inizializzata con il valore $0$. Quest'ultima serve a contare il numero di miglioramenti effettuati durante la computazione, in particolare registra il numero di mosse migliorative effettuate dalla procedura. La variabile è restituita alla fine dell'algoritmo (è stata omessa la porzione di codice relativa alla stampa su console e su file.out nello pseudocodice) e rappresenta il numero di passi (step) effettuati dall'algoritmo. La variabile $count$ è il parametro fondamentale della sperimentazione ed è inoltre il vero e proprio metro di giudizio fra le varie esecuzioni effettuate sulle differenti istanze. La variabile $restart$ viene inizializzata con il valore booleano $True$. Quest'ultima serve, come vedremo tra poco, a reinizializzare l'intero ciclo ogni volta che una mossa migliorativa viene trovata dall'algoritmo. Infine un'ulteriore variabile, $last\_improved\_node$ viene dichiarata e inizializzata con il valore $None$ (valore nullo nel linguaggio Python). Quest'ultima viene utilizzata in una delle 3 strategie di ottimizzazione utilizzate all'interno dell'algoritmo poiché conterrà il valore dell'ultimo nodo che ha effettuato una mossa migliorativa.\\
Il ciclo $while(restart)$ è il ciclo fondamentale e più esterno dell'algoritmo. Come si evince dalla condizione, l'iterazione continua fin tanto che il valore della variabile $restart$ è $True$. Viene ora istanziato il controllo sulla validità del tempo complessivo trascorso, come specificato poco sopra. In particolare se il tempo corrente $time.time() > start + limit$ allora sono trascorsi più di X secondi e l'esecuzione non ha ancora prodotto alcun risultato, dunque modifichiamo con il valore $True$ il contenuto della variabile $time\_limit$ e interrompiamo l'esecuzione corrente uscendo dal ciclo principale dell'algoritmo attraverso l'istruzione $break$. A questo punto la variabile $restart$ viene inizializzata al valore $False$. Solo quando viene trovato un miglioramento quest'ultima viene inizializzata nuovamente al valore $True$ e dunque, se nessun miglioramento viene trovato dall'algoritmo, la condizione all'interno del ciclo $while$ si falsifica è l'esecuzione termina.\\
L'istruzione successiva è un nuovo loop innestato. Questa volta si tratta di un ciclo $for$ che itera, scorrendo uno per volta, tutti i nodi del grafo in oggetto. È stata utilizzata una sintassi molto vicina al codice Python in questa sezione per evidenziare l'utilizzo della funzione $G.nodes(data=True)$. Quest'ultima è una funzione appartenente alla libreria NetworkX che itera tutti i nodi del grafo $G$. In particolare il parametro $data=True$ viene utilizzato per prendere in input all'interno dell'iterazione le etichette associate ai nodi. Come visto in precedenza, le etichette sono dizionari di parametri che caratterizzano il nodo, dunque in questo modo possiamo catturare il contenuto della label $'color'$ che contiene il valore del colore con il quale è colorato il nodo corrente. Assegniamo alle variabili $color\_init$ e $color\_best$ il colore iniziale del nodo corrente attraverso un'operazione di accesso diretto a chiave singola sul dizionario dei parametri associati al nodo con la stringa di codice $data['color']$. Esso rappresenta dunque il colore iniziale assegnato al nodo ($color\_init$) e inoltre rappresenta, in questo momento, il miglior colore trovato per il nodo corrente ($color\_best$). Nella variabile $profit\_old$ viene ora salvato il valore del profitto legato al colore associato al nodo corrente attraverso l'operazione di accesso diretto a chiave doppia sul dizionario $profits$ definita come $profit\_old\gets profits[node][data['color']]$. Il dizionario profits, come specificato nelle sezioni precedenti, è stato creato in precedenza utilizzando la nested dictionary comprehension, ovvero \textit{profits = \{node:\{color:random.randint(0,maxp) for color in colors\} for node in G.nodes()\}}.\\
A questo punto troviamo il primo controllo che ottimizza l'esecuzione dell'algoritmo. In particolare viene confrontato se il valore del nodo corrente $node$ è uguale al valore dell'ultimo nodo migliorato dall'algoritmo $last\_improved\_node$. Questo poiché non è possibile migliorare ulteriormente un nodo che ha appena effettuato una mossa migliorativa e ha indotto un nuovo stato del gioco, ovvero una nuova colorazione. Se la condizione di uguaglianza relativa al blocco $if$ che effettua il controllo viene soddisfatta, l'algoritmo non esegue operazioni sul nodo corrente e passa alla prossima iterazione analizzando un altro nodo attraverso l'istruzione $continue$. Nella successiva istruzione è nuovamente preservata in parte la sintassi del linguaggio Python. Nella variabile $neighbors$ viene salvata la lista (iterabile) dei nodi adiacenti al nodo corrente attraverso la funzione appartenente alla libreria NetworkX $G.neighbors(node)$.\\
A questo punto viene dichiarato un ulteriore ciclo $for$ innestato che itera tutti i nodi (adiacenti al nodo corrente) contenuti nella lista neighbors appena creata con l'istruzione precedente. Ora, come nella definizione del modello, controlliamo se il colore del nodo corrente è diverso dal colore del nodo adiacente. Se la condizione viene soddisfatta salviamo nella variabile $edge\_weight$ il valore del peso associato all'arco che collega i 2 nodi in oggetto e aggiorniamo il valore della variabile $profit\_old$ sommandovi il contenuto della variabile $edge\_weight$. Se la condizione non viene soddisfatta saltiamo l'iterazione corrente con l'istruzione $continue$ e, se disponibile, analizziamo uno degli ulteriori nodi adiacenti al nodo corrente. In questo momento dunque disponiamo del valore di utilità complessivo per il nodo in oggetto colorato con il colore corrente nella colorazione che rappresenta lo stato attuale del gioco. Con i prossimi cicli innestati tentiamo di trovare un colore che garantisca un'utilità migliore per il nodo corrente.\\
In particolare iteriamo, con un ciclo $for$, tutti i colori presenti nella lista $colors$. Ora utilizziamo la seconda strategia di ottimizzazione per snellire la computazione. Il colore selezionato dall'iterazione corrente viene confrontato con il colore del nodo corrente, ovvero vi è un controllo che verifica se la disuguaglianza $current\_color \neq color\_init$ viene soddisfatta o meno. Se la disuguaglianza non viene soddisfatta, significa che il colore corrente è esattamente quello con cui il nodo in oggetto è colorato, passiamo dunque alla prossima iterazione senza eseguire alcuna operazione attraverso l'istruzione $continue$, ciò poiché non avrebbe senso ricalcolare l'utilità del nodo in oggetto per il colore corrente, dato che ciò è stato fatto nel ciclo precedente. Se il colore iterato è diverso dal colore corrente del nodo in oggetto, coloriamo il nodo corrente con il nuovo colore inserendolo come nuovo valore associato alla chiave $'color'$, con l'istruzione $data['color']\gets current\_color$. In seguito inizializziamo al variabile $color\_new$ con il valore del colore corrente contenuto in $current\_color$. Inizializziamo inoltre la variabile $profit\_new$ con il profitto associato al nuovo colore con il quale è colorato ora il nodo corrente. Aggiorniamo ora il valore della variabile $profit\_new$ eseguendo il medesimo ciclo presentato poco sopra, sommandovi il peso degli archi tra il nodo corrente e i suoi vicini se e solo se i colori tra le coppie di nodi analizzate sono differenti. A questo punto eseguiamo un controllo sul valore dell'utilità trovata. In particolare, se la nuova utilità trovata colorando, con un colore differente da quello iniziale, il nodo corrente è maggiore dell'utilità iniziale (if $profit\_new > profit\_old$), aggiorniamo il contenuto della variabile $profit\_old$ con il nuovo valore della variabile $profit\_new$ e modifichiamo il valore del miglior colore trovato $color\_best$ con quello del colore corrente $current\_color$.\\
Descriviamo ora un'ulteriore strategia di ottimizzazione implementata all'interno dell'algoritmo. Come vedremo nelle prossime istruzioni, l'algoritmo, preso il nodo e il colore corrente iniziale, cerca di trovare il colore che garantisce la migliore utilità all'interno della colorazione attuale per il nodo in oggetto. Ciò significa che l'algoritmo non si ferma al primo miglioramento trovato per il nodo corrente, ma cerca di trovare il miglioramento che garantisce la massima utilità possibile per quest'ultimo. In parole povere, itera tutti i $k-1$-colori restanti e trova il colore migliore per il nodo corrente, ovvero quello che garantisce il miglior profitto possibile per quest'ultimo all'interno della colorazione attuale. Alla fine del precedente ciclo innestato infatti, l'algoritmo assegna al nodo corrente il miglior colore trovato attraverso l'istruzione $data['color']\gets color\_best$. Se quest'ultimo è differente dal colore iniziale possiamo affermare che è disponibile un miglioramento per il nodo corrente. Effettuiamo tale miglioramento e aggiorniamo i valori : $count$ (aggiungendo $+1$, poiché l'algoritmo ha eseguito uno step), $restart$ (assegnandole il valore booleano $True$, in modo da garantire la reinizializzazione del ciclo più esterno) e $ last\_improved\_node$ (con il valore del nodo corrente, il quale, essendo stato appena migliorato, non potrà migliorare nuovamente all'iterazione successiva). A questo punto l'iterazione corrente termina e il ciclo viene interrotto dall'uso dell'istruzione $break$. La variabile $restart$, che ora contiene nuovamente il valore $True$ permette la reinizializzazione del ciclo poiché la condizione del $while$ più esterno viene soddisfatta. Se non viene trovato alcun miglioramento, il valore della variabile $restart$ non viene reimpostato a $True$ e dunque, terminata l'iterazione su tutti i nodi del grafo, l'esecuzione corrente viene interrotta.\\
Se il calcolo dell'equilibrio viene portato a termine correttamente e nel tempo limite prestabilito ($if time\_limit == False$), viene eseguito un calcolo congiunto del benessere sociale utilitario e egalitario per la colorazione stabile trovata. Vengono inizializzate al valore $0$ le variabili\\
$egalitarian\_social\_welfare$ e $utilitarian\_social\_welfare$. Viene inoltre inizializzata al valore $True$ la variabile $first\_iter\_check$. A questo punto scorriamo nuovamente tutti i nodi (con annessi i relativi parametri) del grafo corrente, utilizzando il medesimo ciclo $for$ presentato in precedenza durante il calcolo dell'equilibrio. Inizializziamo una variabile temporanea $temp\_egalitarian\_social\_welfare$ con il valore $0$, quest'ultima servirà per il calcolo del benessere sociale egalitario relativo alla colorazione stabile trovata. Modifichiamo il valore della variabile $temp\_egalitarian\_social\_welfare$ e quello della variabile $utilitarian\_social\_welfare$ con il valore del profitto relativo al colore associato al nodo corrente nell'attuale colorazione stabile. Istanziamo nuovamente il loop, utilizzato in precedenza, che itera i nodi adiacenti per ciascun nodo del grafo in oggetto. Salviamo nella variabile $edge\_weight$ il valore del peso dell'arco tra il nodo corrente e uno dei suoi nodi adiacenti se e solo se i colori con i quali sono colorati entrambi i nodi sono differenti, altrimenti non eseguiamo alcuna operazione e saltiamo l'iterazione corrente per passare alla successiva attraverso l'uso dell'istruzione $continue$. In caso di colori differenti, aggiorniamo il valore delle variabili $utilitarian\_social\_welfare$ e $temp\_egalitarian\_social\_welfare$ sommandovi il contenuto della variabile $edge\_weight$. Un ulteriore controllo è quello relativo al conteggio dell'iterazione corrente. Se il valore della variabile booleana $first\_iter\_check$ è $True$, significa che ci troviamo all'interno della prima iterazione, dunque assegniamo semplicemente a $egalitarian\_social\_welfare$ il valore della variabile $temp\_egalitarian\_social\_welfare$, modifichiamo il contenuto della variabile $first\_iter\_check$ al valore $False$ e saltiamo all'iterazione successiva utilizzando l'istruzione $continue$. Per le successive iterazioni (tutte tranne la prima), eseguiamo il seguente controllo. Se il contenuto della variabile \\
$temp\_egalitarian\_social\_welfare < egalitarian\_social\_welfare$, abbiamo trovato un valore migliore per il benessere sociale egalitario relativo alla colorazione stabile.\\
Quindi assegniamo tale valore alla variabile $egalitarian\_social\_welfare$.Al termine dell'iterazione più esterna le variabili \\
$nash\_egalitarian\_social\_welfare$ e $nash\_utilitarian\_social\_welfare$, grazie agli assegnamenti \\
$nash\_utilitarian\_social\_welfare\gets utilitarian\_social\_welfare$ e \\
$nash\_egalitarian\_social\_welfare\gets egalitarian\_social\_welfare$, conterranno rispettivamente i valori del benessere sociale utilitario e egalitario relativi alla colorazione stabile corrente.\\
La seguente procedura, relativa al calcolo del prezzo dell'anarchia utilitario sperimentale e al prezzo dell'anarchia egalitario sperimentale, è stata implementata solo all'interno della modalità SINGLE EXEC, come specificato in precedenza. Verifichiamo a questo punto se sono stati calcolati, per l'istanza corrente, l'ottimo con funzione di benessere sociale utilitario e quello con funzione di benessere sociale egalitario. Se la condizione $if check\_utilitarian\_social\_welfare$ risulta valida, significa che abbiamo già eseguito, sull'istanza corrente, il calcolo dell'ottimo con funzione di benessere sociale utilitario. La variabile $opt\_utilitarian\_social\_welfare$ conterrà il valore relativo al suddetto calcolo dell'ottimo. Assegniamo dunque, in caso la condizione sia valida, il valore della divisione \\
$opt\_utilitarian\_social\_welfare / nash\_utilitarian\_social\_welfare$ alla variabile $utilitarian\_price\_of\_anarchy$. Se la condizione\\
$if check\_egalitarian\_social\_welfare$ risulta valida, significa che abbiamo già eseguito, sull'istanza corrente, il calcolo dell'ottimo con funzione di benessere sociale egalitario. La variabile $opt\_egalitarian\_social\_welfare$ conterrà il valore relativo al suddetto calcolo dell'ottimo. Assegniamo dunque, in caso la condizione sia valida, il valore della divisione\\
$opt\_egalitarian\_social\_welfare / nash\_egalitarian\_social\_welfare$ alla variabile $egalitarian\_price\_of\_anarchy$.

\newpage
\subsection{opt\_utilitarian\_social\_welfare : l'algoritmo per il calcolo dell'ottimo relativo alla funzione di benessere sociale utilitario}
\justify
Il seguente algoritmo viene usato per calcolare la colorazione ottima per il gioco della \(k\)-colorazione generalizzata modellato in precedenza, utilizzando la definizione di funzione di benessere sociale utilitario. Presentiamo ora lo pseudocodice relativo al suddetto algoritmo e di seguito analizziamo in modo accurato le caratteristiche, le iterazioni e le operazioni eseguite nell'implementazione raggiunta. Si specifica che il seguente algoritmo è stato scritto utilizzando la Standard Library del Python e la libreria di costruzione e manipolazione di grafi NetworkX e che l'implementazione è stata accuratamente ottimizzata nei cicli e nelle operazioni grazie ad un attento uso di funzioni e strutture dati. Anche in questo caso, la sintassi dello pseudocodice, in generale nell'aspetto e in particolare in alcuni punti nei quali trascende l'astrazione, è volutamente molto vicina a quella del linguaggio Python in modo tale da coinvolgere il lettore nell'implementazione e in modo da mostrare alcune soluzioni adottate per effettuare le operazioni più significative. Inoltre, come per il caso precedente, sono state omesse nello pseudocodice tutte le porzioni di stampa su console e su file.out dei dati significativi, poiché trascurabili.\\
Si specifica che il calcolo dell'ottimo (sia secondo la definizione di benessere sociale utilitario che egalitario) è una procedura pesante e dispendiosa al livello temporale la cui strategia principale è modellata secondo la forza bruta. In particolare tale procedura è incentrata sull'uso delle permutazioni, ciascuna delle quali rappresenta una possibile colorazione per l'istanza corrente. Tale aspetto è fortemente esponenziale, infatti avendo \(k\) colori e \(n\) nodi, il numero di permutazioni da iterare corrisponde a \(k^n\). Per non tediare il lettore, specifichiamo che, per chiarezza, le qui presenti assunzioni e affermazioni verranno riportate anche nella sezione di analisi dell'algoritmo successivo, quello per il calcolo dell'ottimo con funzione di benessere sociale egalitario. Dunque lo invitiamo a saltare la lettura di tali assunzioni nella sezione successiva poiché saranno le medesime già lette in questo paragrafo.

\newpage
\begin{algorithmic}

\State $start\gets time.time()$
\State $limit\gets X$ \Comment X assegnato dinamicamente dall'utente
\State $time\_limit\gets False$ \\

\State $utilitarian\_social\_welfare\gets 0$
\State $permutations\gets list(itertools.product(colors, repeat=G.number\_of\_nodes()))$ \\

\For{$permutation \in permutations$}
	\If{$time.time() > start + limit$}
		\State $time\_limit\gets True$ 
		\State \textbf{break}
	\EndIf
	\State $colouring\_old = permutation$
	\For{$(node,data) \in G.nodes(data=True)$}
		\State $data['color']\gets permutation[node]$
	\EndFor
	\State $temp\_utilitarian\_social\_welfare\gets 0$
	\For{$(node,data) \in G.nodes(data=True)$}
		\State $temp\_utilitarian\_social\_welfare += profits[node][data['color']]$
		\State $neighbors\gets G.neighbors(node)$
		\For{$neighbor \in neighbors$}
			\If{$G.node[neighbor]['color'] \neq G.node[node]['color']$}
				\State $edge\_weight\gets G[node][neighbor]['weight']$
				\State $temp\_utilitarian\_social\_welfare += edge\_weight$
			\Else
				\State \textbf{continue}
			\EndIf
		\EndFor
	\EndFor
	\If{$temp\_utilitarian\_social\_welfare > utilitarian\_social\_welfare$}
		\State $utilitarian\_social\_welfare\gets temp\_utilitarian\_social\_welfare$
		\State $colouring\_best\gets colouring\_old$
	\Else
		\State \textbf{continue}
	\EndIf
\EndFor \\

\If{$time\_limit == False$}
	\State $check\_utilitarian\_social\_welfare\gets True$
	\State $opt\_utilitarian\_social\_welfare\gets utilitarian\_social\_welfare$
\EndIf 

\end{algorithmic} 

\newpage
All'inizio impostiamo, come nella sezione precedente, il limitatore temporale inizializzando la variabile $start$ con il valore temporale iniziale, la variabile $limit$ con il valore limite di $X$ secondi e la variabile booleana $time\_limit$ con il valore $False$. Dichiariamo la variabile $utilitarian\_social\_welfare$ e assegniamole il valore $0$. Generiamo a questo punto tutte le possibili permutazioni con ripetizione tra nodi e colori dell'istanza corrente. Come specificato in precedenza, l'operazione potrebbe essere molto pesante, poiché vengono generate \(k^n\) permutazioni, con $k$ uguale al numero di colori e $n$ uguale al numero di nodi del grafo corrente. La funzione per generare la seguente lista di permutazione utilizza primitive interne alla Standard Library del linguaggio Python, $permutations\gets list(itertools.product(colors, repeat=G.number\_of\_nodes()))$. A questo punto iteriamo tutte le permutazioni contenute all'interno della lista generata nell'operazione precedente. Viene effettuato in questo punto il medesimo controllo sulla validità del tempo trascorso esplicato nella sezione precedente, le operazioni sono esattamente le stesse. Se il tempo di esecuzione corrente è valido (\(\leq X secondi\)), salviamo la colorazione attuale, ovvero la permutazione corrente, nella variabile $colouring\_old$.\\
Iteriamo a questo punto tutti i nodi del grafo in oggetto attraverso un ciclo $for$ identico a quello utilizzato nella sezione precedente. Assegniamo a ciascun nodo, in sequenza, 1 colore appartenente alla permutazione corrente mediante l'istruzione $data['color']\gets permutation[node]$, ottenendo così una colorazione per il grafo corrente. Dichiariamo ora la variabile temporanea $temp\_utilitarian\_social\_welfare$ e inizializziamola al valore $0$, quest'ultima ci servirà per calcolare il valore del benessere sociale utilitario per la colorazione corrente. Iteriamo nuovamente i nodi, con la medesima operazione descritta poco sopra (ciclo $for$). Sommiamo, per ciascun nodo iterato, il valore del profitto associato al colore con il quale è colorato il nodo corrente al valore contenuto nella variabile $temp\_utilitarian\_social\_welfare$. Generiamo ora la lista di tutti i nodi adiacenti al nodo corrente attraverso l'istruzione $neighbors\gets G.neighbors(node)$, utilizzata anche nella sezione precedente.\\
Iteriamo a questo punto tutti i nodi adiacenti al nodo corrente attraverso il medesimo ciclo $for$ presentato durante la descrizione dell'algoritmo per il calcolo della colorazione stabile. Istanziamo ora un controllo sulla validità del colore tra le coppie di nodi, lo stesso utilizzato nella sezione precedente. Se la condizione $G.node[neighbor]['color'] \neq G.node[node]['color']$ è valida otteniamo che i colori tra il nodo corrente e uno dei suoi nodi adiacenti sono differenti, dunque salviamo all'interno della variabile $edge\_weight$ il valore del peso dell'arco che congiunge la coppia di nodi analizzata attraverso l'istruzione $edge\_weight\gets G[node][neighbor]['weight']$ e aggiorniamo il contenuto della variabile $temp\_utilitarian\_social\_welfare$ sommandovi il valore della variabile $edge\_weight$. Se la condizione esplicata in precedenza non è valida, non eseguiamo alcuna operazione e saltiamo l'iterazione corrente attraverso l'istruzione $continue$, in modo tale da iterare, se disponibile, il prossimo nodo adiacente al nodo corrente e ripetere il controllo. A questo punto la variabile $temp\_utilitarian\_social\_welfare$ conterrà il valore totale relativo al benessere sociale utilitario correlato alla colorazione attuale (permutazione corrente). Viene ora effettuato un controllo sul valore di benessere sociale utilitario trovato in precedenza.Se la condizione \\
$temp\_utilitarian\_social\_welfare > utilitarian\_social\_welfare$ è valida, abbiamo trovato un valore migliore per il benessere sociale utilitario relativo all'istanza corrente. Modifichiamo il valore della variabile\\
$utilitarian\_social\_welfare$ con il valore della variabile \\
$temp\_utilitarian\_social\_welfare$ e assegniamo alla variabile $colouring\_best$ il valore della variabile $colouring\_old$ (che contiene la tupla relativa alla colorazione attuale, ovvero la permutazione corrente). Se la condizione \\
$temp\_utilitarian\_social\_welfare > utilitarian\_social\_welfare$ è valida, non viene effettuata alcuna operazione e viene saltata l'iterazione corrente attraverso l'utilizzo dell'istruzione $continue$.\\
A questo punto, se è stato calcolato il risultato ottimo all'interno del range temporale prestabilito, viene modificato al valore $True$ il contenuto della variabile $check\_utilitarian\_social\_welfare$ e viene assegnato alla variabile $opt\_utilitarian\_social\_welfare$ il valore della variabile \\
$utilitarian\_social\_welfare$ che contiene il risultato ottimo trovato. Il valore della variabile $check\_utilitarian\_social\_welfare$, quando uguale a $True$, ci permette di calcolare, in modalità SINGLE EXEC, il prezzo dell'anarchia sperimentale utilitario. Al termine dell'esecuzione la variabile $colouring\_best$ conterrà la tupla che descrive e rappresenta la colorazione ottima e la variabile \\
$opt\_utilitarian\_social\_welfare$ ($utilitarian\_social\_welfare$) conterrà il valore ottimo relativo alla funzione di benessere sociale utilitario per l'istanza corrente.

\newpage
\subsection{opt\_egalitarian\_social\_welfare : l'algoritmo per il calcolo dell'ottimo relativo alla funzione di benessere sociale egalitario}
\justify
Il seguente algoritmo viene usato per calcolare la colorazione ottima per il gioco della \(k\)-colorazione generalizzata modellato in precedenza, utilizzando la definizione di funzione di benessere sociale egalitario. Presentiamo ora lo pseudocodice relativo al suddetto algoritmo e di seguito analizziamo in modo accurato le caratteristiche, le iterazioni e le operazioni eseguite nell'implementazione raggiunta. Si specifica che il seguente algoritmo è stato scritto utilizzando la Standard Library del Python e la libreria di costruzione e manipolazione di grafi NetworkX e che l'implementazione è stata accuratamente ottimizzata nei cicli e nelle operazioni grazie ad un attento uso di funzioni e strutture dati. Anche in questo caso, la sintassi dello pseudocodice, in generale nell'aspetto e in particolare in alcuni punti nei quali trascende l'astrazione, è volutamente molto vicina a quella del linguaggio Python in modo tale da coinvolgere il lettore nell'implementazione e in modo da mostrare alcune soluzioni adottate per effettuare le operazioni più significative. Inoltre, come per il caso precedente, sono state omesse nello pseudocodice tutte le porzioni di stampa su console e su file.out dei dati significativi, poiché trascurabili.\\
Si specifica che il calcolo dell'ottimo (sia secondo la definizione di benessere sociale utilitario che egalitario) è una procedura pesante e dispendiosa al livello temporale la cui strategia principale è modellata secondo la forza bruta. In particolare tale procedura è incentrata sull'uso delle permutazioni, ciascuna delle quali rappresenta una possibile colorazione per l'istanza corrente. Tale aspetto è fortemente esponenziale, infatti avendo \(k\) colori e \(n\) nodi, il numero di permutazioni da iterare corrisponde a \(k^n\).

\newpage
\begin{algorithmic}

\State $start\gets time.time()$
\State $limit\gets X$ \Comment X assegnato dinamicamente dall'utente
\State $time\_limit\gets False$ \\

\State $temp\_egalitarian\_social\_welfare\gets 0$
\State $egalitarian\_social\_welfare\gets 0$
\State $permutations\gets list(itertools.product(colors, repeat=G.number\_of\_nodes()))$
\State $first\_iter\_check\gets True$
\State $first\_iter\_opt\_check\gets True$ \\

\For{$permutation \in permutations$}
	\If{$time.time() > start + limit$}
		\State $time\_limit\gets True$ 
		\State \textbf{break}
	\EndIf
	\State $colouring\_old = permutation$
	\For{$(node,data) \in G.nodes(data=True)$}
		\State $data['color']\gets permutation[node]$
	\EndFor
	\For{$(node,data) \in G.nodes(data=True)$}
		\State $local\_egalitarian\_social\_welfare\gets 0$
		\State $local\_egalitarian\_social\_welfare\gets profits[node][data['color']]$
		\State $neighbors\gets G.neighbors(node)$
		\For{$neighbor \in neighbors$}
			\If{$G.node[neighbor]['color'] \neq G.node[node]['color']$}
				\State $edge\_weight\gets G[node][neighbor]['weight']$
				\State $local\_egalitarian\_social\_welfare += edge\_weight$
			\Else
				\State \textbf{continue}
			\EndIf
		\EndFor
		\If{$first\_iter\_check$}
			\State $temp\_egalitarian\_social\_welfare\gets local\_egalitarian\_social\_welfare$
			\State $first\_iter\_check\gets False$
			\State \textbf{continue}
		\EndIf	
		\If{$local\_egalitarian\_social\_welfare < temp\_egalitarian\_social\_welfare$}
			\State $temp\_egalitarian\_social\_welfare\gets local\_egalitarian\_social\_welfare$
		\Else
			\State \textbf{continue}	
		\EndIf
	\State $first\_iter\_check\gets True$
	\If{$first\_iter\_opt\_check$}
		\State $egalitarian\_social\_welfare\gets temp\_egalitarian\_social\_welfare$
		\State $colouring\_best\gets colouring\_old$
		\State $first\_iter\_opt\_check\gets False$
		\State \textbf{continue}
	\EndIf	
	\If{$temp\_egalitarian\_social\_welfare > egalitarian\_social\_welfare$}
		\State $egalitarian\_social\_welfare\gets temp\_egalitarian\_social\_welfare$
		\State $colouring\_best\gets colouring\_old$
	\Else
		\State \textbf{continue}	
	\EndIf
	\EndFor
\EndFor \\

\If{$time\_limit == False$}
	\State $check\_egalitarian\_social\_welfare\gets True$
	\State $opt\_egalitarian\_social\_welfare\gets egalitarian\_social\_welfare$
\EndIf

\end{algorithmic}

\newpage
All'inizio, come per gli algoritmi descritti in precedenza, impostiamo il valore del limitatore temporale relativo al tempo di esecuzione massimo accettato in fase di sperimentazione. Inizializziamo le variabili $start$, $limit$ e $time\_limit$ ai valori $0$, $X$ (X secondi) e $False$ rispettivamente. Dichiariamo e inizializziamo al valore $0$ le variabili \\
$temp\_egalitarian\_social\_welfare$ e $egalitarian\_social\_welfare$ che ci serviranno per il calcolo del benessere sociale egalitario per l'istanza corrente. Generiamo ora tutte le possibili permutazioni con ripetizione tra nodi e colori dell'istanza corrente, come effettuato in precedenza. Anche in questo caso l'operazione potrebbe essere molto pesante, poiché vengono generate \(k^n\) permutazioni, con $k$ uguale al numero di colori e $n$ uguale al numero di nodi del grafo corrente. La funzione per generare la seguente lista di permutazione utilizza primitive interne alla Standard Library del linguaggio Python, $permutations\gets list(itertools.product(colors, repeat=G.number\_of\_nodes()))$. Inizializziamo inoltre al valore $True$ le variabili $first\_iter\_check$ e $first\_iter\_opt\_check$ che ci serviranno all'interno di successivi controlli durante le iterazioni.\\
A questo punto iteriamo tutte le permutazioni contenute all'interno della lista generata nell'operazione precedente. Viene effettuato in questo punto il medesimo controllo sulla validità del tempo trascorso esplicato nella sezione precedente, le operazioni sono esattamente le stesse. Se il tempo di esecuzione corrente è valido (\(\leq X secondi\)), salviamo la colorazione attuale, ovvero la permutazione corrente, nella variabile $colouring\_old$.\\
Iteriamo a questo punto tutti i nodi del grafo in oggetto attraverso un ciclo $for$ identico a quello utilizzato nella sezione precedente. Assegniamo a ciascun nodo, in sequenza, 1 colore appartenente alla permutazione corrente mediante l'istruzione $data['color']\gets permutation[node]$, ottenendo così una colorazione per il grafo corrente.\\
Iteriamo nuovamente i nodi, con la medesima operazione descritta poco sopra (ciclo $for$). Per ciascun nodo iterato, inizializziamo al valore $0$ la variabile \\
$local\_egalitarian\_social\_welfare$ e, nell'istruzione successiva, modifichiamo il contenuto di quest'ultima sommandovi il valore del profitto associato al colore con il quale è colorato il nodo corrente. Generiamo ora la lista di tutti i nodi adiacenti al nodo corrente attraverso l'istruzione $neighbors\gets G.neighbors(node)$ utilizzata anche nella sezione precedente.\\
Iteriamo a questo punto tutti i nodi adiacenti al nodo corrente attraverso il medesimo ciclo $for$ presentato durante la descrizione dell'algoritmo per il calcolo della colorazione stabile. Istanziamo ora un controllo sulla validità del colore tra le coppie di nodi, lo stesso utilizzato nella sezione precedente. Se la condizione $G.node[neighbor]['color'] \neq G.node[node]['color']$ è valida otteniamo che i colori tra il nodo corrente e uno dei suoi nodi adiacenti sono differenti, dunque salviamo all'interno della variabile $edge\_weight$ il valore del peso dell'arco che congiunge la coppia di nodi analizzata attraverso l'istruzione $edge\_weight\gets G[node][neighbor]['weight']$ e aggiorniamo il contenuto della variabile $local\_egalitarian\_social\_welfare$ sommandovi il valore della variabile $edge\_weight$. Se la condizione esplicata in precedenza non è valida, non eseguiamo alcuna operazione e saltiamo l'iterazione corrente attraverso l'istruzione $continue$, in modo tale da iterare, se disponibile, il prossimo nodo adiacente al nodo corrente e ripetere il controllo.\\
A questo punto viene effettuato un controllo sull'iterazione corrente. Se il valore contenuto nella variabile $first\_iter\_check$ è uguale a $True$, deduciamo che, quella corrente, è la prima iterazione. Dunque assegniamo il valore contenuto nella variabile \\
$local\_egalitarian\_social\_welfare$ all'interno della variabile \\
$temp\_egalitarian\_social\_welfare$, modifichiamo il contenuto della variabile $first\_iter\_check$ con il valore $False$ e passiamo alla prossima iterazione attraverso l'uso dell'istruzione $continue$. Qualora ci trovassimo in un'iterazione differente dalla prima, istanziamo il seguente controllo. Se il valore della variabile \\
$local\_egalitarian\_social\_welfare < temp\_egalitarian\_social\_welfare$, abbiamo trovato un risultato migliore per il calcolo del benessere sociale egalitario. Dunque assegniamo alla variabile $temp\_egalitarian\_social\_welfare$ il valore della variabile $local\_egalitarian\_social\_welfare$. Se il valore della variabile \\
$local\_egalitarian\_social\_welfare \geq temp\_egalitarian\_social\_welfare$, non eseguiamo alcuna operazione e iteriamo il prossimo nodo del grafo attraverso l'utilizzo dell'istruzione $continue$. A questo punto poniamo nuovamente a $True$ il valore della variabile $first\_iter\_check$ e istanziamo il seguente controllo sull'ottimalità del valore trovato. Se il valore contenuto nella variabile $first\_iter\_opt\_check$ è uguale a $True$, deduciamo che, quella corrente, è la prima iterazione relativa al test sull'ottimalità del valore trovato. Dunque assegniamo il valore contenuto nella variabile \\
$temp\_egalitarian\_social\_welfare$ all'interno della variabile \\
$egalitarian\_social\_welfare$, assegniamo il valore della variabile $colouring\_old$ (che contiene la tupla corrispondente alla colorazione corrente) alla variabile $colouring\_best$, modifichiamo il contenuto della variabile $first\_iter\_opt\_check$ con il valore $False$ e passiamo alla prossima iterazione attraverso l'uso dell'istruzione $continue$. Qualora ci trovassimo in un'iterazione, relativa al test di ottimalità della soluzione trovata, differente dalla prima, istanziamo il seguente controllo. Se il valore della variabile \\
$temp\_egalitarian\_social\_welfare > egalitarian\_social\_welfare$, abbiamo trovato un risultato migliore per il calcolo del benessere sociale egalitario. Dunque assegniamo alla variabile $egalitarian\_social\_welfare$ il valore della variabile $temp\_egalitarian\_social\_welfare$ e assegniamo il valore della variabile $colouring\_old$ (che contiene la tupla corrispondente alla colorazione corrente) alla variabile $colouring\_best$. Se il valore della variabile \\
$temp\_egalitarian\_social\_welfare \leq egalitarian\_social\_welfare$, non eseguiamo alcuna operazione e iteriamo il prossimo nodo del grafo attraverso l'utilizzo dell'istruzione $continue$.\\
A questo punto, se è stato calcolato il risultato ottimo all'interno del range temporale prestabilito, viene modificato al valore $True$ il contenuto della variabile $check\_egalitarian\_social\_welfare$ e viene assegnato alla variabile $opt\_egalitarian\_social\_welfare$ il valore della variabile \\
$egalitarian\_social\_welfare$ che contiene il risultato ottimo trovato. Il valore della variabile $check\_egalitarian\_social\_welfare$, quando uguale a $True$, ci permette di calcolare, in modalità SINGLE EXEC, il prezzo dell'anarchia sperimentale egalitario. Al termine dell'esecuzione la variabile $colouring\_best$ conterrà la tupla che descrive e rappresenta la colorazione ottima e la variabile \\
$opt\_egalitarian\_social\_welfare$ ($egalitarian\_social\_welfare$) conterrà il valore ottimo relativo alla funzione di benessere sociale egalitario per l'istanza corrente.\\

Abbiamo terminato a questo punto la trattazione approfondita riguardante i programmi e gli algoritmi implementati. Analizziamo ora, all'interno del capitolo relativo alla sperimentazione, i risultati e le conclusioni ottenute dalle molteplici esecuzione effettuate. In particolare descriveremo, nella parte iniziale, i moduli per la creazione e per la lettura utilizzati all'iterno della fase di sperimentazione. Nel dettaglio specifichiamo che verranno analizzate parti specifiche del programma generator.py e del programma reader.py relative alla generazione e lettura di grafi randomici. In seguito presenteremo sotto forma di tabelle riassuntive i molteplici risultati raccolti dalle varie sessioni di sperimentazione e trarremo le dovute conclusioni dallo studio e dall'analisi effettuata.