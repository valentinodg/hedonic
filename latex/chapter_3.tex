\chapter{Implementazione}

In questo capitolo andremo a delineare e descrivere gli aspetti fondamentali ed essenziali relativi all'attività di implementazione.\\

Inizieremo con una presentazione della struttura generale dei programmi assieme ad una descrizione accurata dei componenti utilizzati e delle scelte effettuate in fase di progettazione.\\

In seguito procederemo con un'attenta analisi degli algoritmi implementati, ovvero il l'algoritmo per il calcolo degli equilibri di Nash, quello per il calcolo dell'ottimo relativo alla funzione di benessere sociale utilitario e quello per il calcolo dell'ottimo relativo alla funzione di benessere sociale egalitario.\\
Tale sezione sarà caratterizzata dall'utilizzo di pseudocodice per ciascuno degli algoritmi in modo tale da rendere più comprensibile la descrizione dei cicli e delle operazioni.\\

Tratteremo in modo approfondito questa porzione del documento poiché precede la sezione relativa alla sperimentazione effettuata attraverso i programmi implementati e dunque è di fondamentale importanza.\\

\section{Struttura generale}
\justify

Procediamo presentando la struttura generale relativa programmi implementati.\\ 
Quest'ultima è rappresentata attraverso una struttura ad albero che riproduce una porzione di filesystem partendo dalla root del progetto.\\
Al fine di rendere più chiara la lettura viene inoltre fornita un breve leggenda sulla nomenclatura utilizzata.

\begin{itemize}
	\item La nomenclatura \textbf{nome.dir} indica che l'oggetto è una cartella
	\item La nomenclatura \textbf{nome.edgelist} indica che l'oggetto è un file con estensione .edgelist (oggetto principale modellato dal programma)
	\item La nomenclatura \textbf{nome.dot} indica che l'oggetto è un file con estensione .dot (oggetto utilizzato su macchine GNU/Linux per il disegno attraverso la libreria PyGraphViz in fase di debug)
	\item le lettere \textbf{X,K,Y,Z,H,W} rappresentano numeri casuali (sono utilizzate per descrivere la moltitudine di cartelle, grafi creati e risultati, ottenuti durante un generale caso d'uso dei programmi)
	\item la nomenclatura \textbf{nome.init} indica che l'oggetto è un file con estensione .init (oggetto utilizzato in fase di lettura per salvare le caratteristiche dei grafi (nodi, archi, pesi, colorazione) e dei colori (colori, profitti))
	\item la nomenclatura \textbf{nome.out} indica che l'oggetto è un file con estensione .out (oggetto utilizzato in fase di lettura per salvare i risultati derivanti da esecuzioni singole o multiple usando gli algoritmi per il calcolo del nash, dell'ottimo con funzione di benessere sociale utilitario e dell'ottimo con funzione di benessere sociale egalitario)
\end{itemize}

Descriviamo ora la funzione basilare di alcuni componenti dell'albero sottostante rappresentante un esempio generale relativo ad un caso d'uso dei programmi.

\begin{itemize}
	\item La cartella \textbf{generator} contiene al suo interno l'intera struttura relativa al generatore di grafi
	\item La cartella \textbf{gen} contiene i risultati delle generazioni singole di grafi
	\begin{enumerate}
		\item Al suo interno vi sono X cartelle gen-dir-X (il nome viene assegnato dinamicamente dall'utente) generate dinamicamente
		\item Ciascuna cartella contiene il risultato di una generazione singola di un grafo sotto forma di una coppia di file .edgelist e .dot (utilizzato solo in fase di debug)
		\item Ogni gruppo cartella-file.edgelist-file.dot rappresenta il risultato di una generazione singola
	\end{enumerate}
	\item La cartella \textbf{m-gen} contiene i risultati delle generazioni multiple di grafi
	\begin{enumerate}
		\item Al suo interno vi sono Y cartelle m-gen-dir-Y (il nome viene assegnato dinamicamente dall'utente) generate dinamicamente
		\item Ciascuna cartella contiene il risultato di una generazione multipla di grafi sotto forma di molteplici coppie (nell'esempio K,Z,...) di file .edgelist e .dot (utilizzato solo in fase di debug)
		\item Ogni gruppo cartella-file.edgelist-file.dot-file.edgelist-file.dot-... indica il risultato di una generazione multipla
	\end{enumerate}
	\item Il file \textbf{generator.py} contiene al suo interno il codice del generatore di grafi scritto interamente in linguaggio Python
\end{itemize}

\begin{itemize}
	\item La cartella \textbf{reader} contiene al suo interno l'intera struttura relativa al lettore di grafi
	\item La cartella \textbf{result} contiene i risultati delle letture / sperimentazioni su grafi singoli
	\begin{enumerate}
		\item Al suo interno vi sono H cartelle result-dir-H (il nome viene preso dinamicamente dal grafo in lettura) generate dinamicamente
		\item Ciascuna cartella contiene il singolo risultato di una lettura / sperimentazione su un grafo sotto forma di una coppia di file .init e .out
		\item Ogni gruppo cartella-file.init-file.out rappresenta il risultato di una singola lettura / sperimentazione 
	\end{enumerate}
	\item La cartella \textbf{m-result} contiene i risultati delle letture / sperimentazioni su molteplici grafi
	\begin{enumerate}
		\item Al suo interno vi sono W cartelle m-result-dir-W (il nome viene preso dinamicamente dalla cartella relativa alla moltitudine di grafi in lettura) generate dinamicamente
		\item Ciascuna cartella contiene multipli risultati di multiple letture / sperimentazioni su grafo multipli sotto forma di una coppia di file .init e .out
		\item Ogni gruppo cartella-file.init-file.out rappresenta il risultato di una lettura / sperimentazione multipla
	\end{enumerate}
	\item Il file \textbf{reader.py} contiene al suo interno il codice del lettore di grafi scritto interamente in linguaggio Python 
\end{itemize}

\newpage
\dirtree{%
.1 /.
.2 generator.dir.
.3 gen.dir.
.4 gen-dir-1.dir.
.5 graph-1.edgelist.
.5 graph-1.dot.
.4 .....
.4 gen-dir-X.dir.
.5 graph-X.edgelist.
.5 graph-X.dot.
.3 m-gen.dir.
.4 m-gen-dir-1.dir. 
.5 graph-1.edgelist.
.5 graph-1.dot.
.5 .....
.5 graph-K.edgelist.
.5 graph-K.dot.
.4 .....
.4 m-gen-dir-Y.dir.
.5 graph-1.edgelist.
.5 graph-1.dot.
.5 .....
.5 graph-Z.edgelist.
.5 graph-Z.dot.
.3 generator.py.
.2 reader.dir.
.3 result.dir.
.4 result-dir-1.dir.
.5 graph-1.init.
.5 graph-1.out.
.4 .....
.4 result-dir-H.dir.
.5 graph-H.init.
.5 graph-H.out.
.3 m-result.dir.
.4 m-result-dir-1.dir.
.5 graph-1.init.
.5 graph-1.out.
.4 .....
.4 m-result-dir-W.dir.
.5 graph-W.init.
.5 graph-W.out.
}

\section{Componenti utilizzati e progettazione}
\justify
I programmi generator.py e reader.py sono stati interamente scritti utilizzando il linguaggio Python [versione 3.6.5].\\

Il codice è stato scritto utilizzando differenti editor di testo (vim [neovim], spacemacs, sublime-text, atom,...) e testato su diverse macchine GNU/Linux e Windows, in particolare su differenti shell (bash, zsh, fish) e su cmd.\\

Per agevolare il processo di progettazione e scrittura del codice l'intera struttura del progetto è stata caricata in una repository sul sito github e gestita in remoto (attraverso il software git).\\

Per questioni di compatibilità e versatilità è stata utilizzata in modo massiccio la libreria standard relativa al linguaggio Python per effettuare la quasi totalità delle operazioni in entrambi i programmi.\\

La versione di riferimento della libreria è quella associata alla versione del linguaggio utilizzato, dunque la 3.6.5.\\

Al fine di trascurare alcuni aspetti relativi alla strutturazione e costruzione dei grafi è stata utilizzata una potente libreria per la creazione e la manipolazione di questi oggetti matematici, ovvero NetworkX.\\

Tale scelta di progettazione ha permesso al sottoscritto di concentrarsi maggiormente sulla progettazione e sull'ottimizzazione degli algoritmi.\\

Inoltre tale scelta ha consentito al sottoscritto di rendere totalmente dinamici i processi di creazione e lettura dei grafi, ciò ha facilitato di molto il carico di lavoro in fase di sperimentazione.\\

La libreria standard del linguaggio Python è stata utilizzata in particolare per rendere totalmente dinamica e cross-platform la gestione del filesystem.\\

Ciò è stato necessario per garantire il funzionamento asincrono del generatore e del lettore, in modo tale da facilitare il lavoro in fase di sperimentazione.\\

Le fasi di generazione e lettura dei grafi infatti sono state completamente separate al livello di utilizzo, per fare ciò è stato necessario manipolare efficientemente il filesystem in modo da salvare i grafi creati e i risultati delle sperimentazioni su file.\\

Tali operazioni sono perfettamente funzionanti sia su sistemi che rispettano lo standard POSIX (Sistemi Unix-like) per il filesystem sia per sistemi che non lo rispettano (Sistemi Windows), dunque l'intero progetto è totalmente cross-platform e può essere facilmente migrato rendendo la portabilità un importante fattore di forza di quest'ultimo.\\

Il formato principale manipolato dai programmi è il formato .edgelist che analizzeremo in seguito.\\

In fase di debug è stata utilizzata la libreria di disegno MatPlotLib per rappresentare i grafi, quest'ultima è integrata in modo nativo all'interno della libreria NetworkX, dunque tale scelta di utilizzo ha reso più facili le operazioni di analisi e debug.\\

Un'altra libreria che è stata utilizzata in fase di analisi e debug per rappresentare i grafi in ambiente GNU/Linux è la libreria di disegno PyGraphViz.\\

Anche quest'ultima è integrata in modo nativo all'interno della libreria NetworkX.\\

Il formato di descrizione testuale dei grafi .dot è stato utilizzato solo in fase di debug in ambiente GNU/Linux assieme alla libreria di disegno PyGraphViz, dunque possiamo tralasciare la sua definizione e descrizione poiché non viene utilizzato all'interno dei programmi durante l'esecuzione.\\

Altre librerie minori sono state scelte in fase di progettazione ed utilizzate all'interno dei programmi, ad esempio la libreria per la colorazione dell'output testuale su terminal emulators cross-platform Colorama è stata utilizzata in fase di analisi e debug per semplificare e rendere più chiara la lettura dell'output relativo all'esecuzione degli algoritmi.\\

Un altro esempio è l'utilizzo della libreria cross-platform Pick, che rende semplice ed efficace la selezione delle opzioni all'interno dei terminal emulators durante l'esecuzione dei programmi.\\

L'elenco completo delle librerie utilizzate all'interno dei programmi è il seguente.

\begin{itemize}
	\item Python Standard Library (Python 3.6.5 - Python 2.7.14)\\
	https://docs.python.org/3/library/
	\item NetworkX Library (NetworkX 2.1)\\ 	
	https://pypi.org/project/networkx/	
	\item Matplotlib Library (Matplotlib 2.2)\\
	https://pypi.org/project/matplotlib/
	\item Pick Library (Pick 0.6.4)\\
	https://pypi.org/project/pick/
	\item Pydot Library (Pydot 1.2.4)\\
	https://pypi.org/project/pydot/
	\item Graphviz Library (Graphviz 0.8.2)\\
	https://pypi.org/project/graphviz/
	\item PyParsing Library (PyParsing 2.2.0)\\
	https://pypi.org/project/pyparsing/
	\item Colorama Library (Colorama 0.3.9)\\
	https://pypi.org/project/colorama/
\end{itemize}

Per il funzionamento completo dei programmi è necessaria l'installazione di Python e dei suddetti componenti attraverso l'uso del modulo pip e/o l'uso di package manager (apt, pacman, ...).\\

Procediamo ora nella trattazione descrivendo il funzionamento dei programmi generator.py e reader.py.\\
Saranno poi analizzati in modo approfondito gli algoritmi per il calcolo degli equilibri di Nash e degli ottimi.\\

\section{generator.py : il generatore di grafi}
\justify
Il programma generator.py è un generatore dinamico di grafi scritto interamente in Python in grado di semplificare le operazioni di creazione e manipolazione di questi oggetti matematici e in grado di creare automaticamente tutte le strutture di filesystem necessarie al salvataggio dei grafi generati su file.\\

Il programma come specificato in precedenza è completamente cross-platform e per ciò che riguarda la gestione del filesystem è stato accuratamente ottimizzato per non generare conflitti e problemi di inconsistenza dei dati.\\

Principalmente il programma utilizza due moduli principali necessari al corretto funzionamento dello stesso, la Standard Library del linguaggio Python per le funzioni di base e la libreria NetworkX per la creazione e manipolazione dei grafi.\\

Di seguito vengono riportate le caratteristiche del programma assieme ad un esempio generale di un caso d'uso.\\

Per prima cosa vengono impostati i motori di disegno, ovvero le librerie MatPlotLib e PyGraphViz.\\
Quest'ultima è stata utilizzata solo in ambiente GNU/Linux in fase di debug, dunque non è disponibile per l'utente.\\

In compenso è però disponibile per l'utente la libreria MatPlotLib che consente a quest'ultimo, qualora volesse, di disegnare al termine della generazione i grafi appena creati.\\
È di fondamentale importanza però specificare che il processo di disegno per grafi di grandi dimensioni è molto dispendioso e dunque può richiedere un tempo considerevole.\\

Come prima operazione all'avvio del programma è disponibile per l'utente una scelta della classe di grafo da generare effettuata attraverso un interfaccia di selezione da console implementata grazie alla libreria Pick.\\

Sono disponibili per l'utente 2 modalità di funzionamento per la generazione, la modalità SINGLE MODE (la modalità di default del programma) e la modalità MULTIPLE MODE (accessibile attraverso la selezione dell'opzione MULTIPLE nella scelta della classe).\\

\subsection{generator.py : SINGLE MODE}
\justify
Le classi implementate fanno riferimento a quelle presenti nella libreria NetworkX, ovvero le seguenti (se ne citano solo alcune).

\begin{itemize}
	\item Classic
	\item Expanders
	\item Small 
	\item Random graphs 
	\item Duplication divergence 
	\item ...
	\item MULTIPLE
\end{itemize}

Una volta selezionata la classe desiderata l'utente si troverà davanti una nuova interfaccia di selezione da console implementata attraverso l'uso del modulo Pick.\\

L'opzione MULTIPLE cambia la tipologia di funzionamento del programma, che da SINGLE MODE (modalità di generazione di un singolo grafo per volta) passa a MULTIPLE MODE (nella quale possono essere generati da 1 a n grafi della stessa tipologia in un solo processo di creazione, con n scelto dall'utente).\\
Concentriamoci ora sulla SINGLE MODE, la default mode del programma.\\

Questa volta l'utente dovrà scegliere la tipologia di grafo da creare.\\
Per ogni classe vi sono molteplici tipologie di grafo che l'utente può scegliere di generare.\\

Le tipologie implementate fanno riferimento a quelle presenti nel modulo NetworkX, in particolare ciascuna tipologia ha un costruttore di libreria corrispondente che provvede a generare le strutture elementari e a comporre l'oggetto matematico richiesto dall'utente.\\

Solo per far comprendere al lettore la vastità delle scelte possibili per l'utente in fase di selezione del grafo da generare, vengono qui si seguito riportate le tipologie di grafi implementate per la sola classe di grafi Classic.

\begin{itemize}
	\item balanced tree
	\item complete graph
	\item circular ladder graph
	\item cycle graph
	\item dorogovtsev goltsev mendes graph
	\item ladder graph
	\item lollipop graph
	\item path graph
	\item star graph
	\item turan graph
	\item wheel graph
	\item ...
\end{itemize}

Una volta selezionata la tipologia di grafo da implementare, l'utente potrà inserire i parametri di creazione per quest'ultimo.\\
I parametri associati ai grafi variano da tipologia a tipologia e sono necessari e fondamentali per la corretta generazione del grafo scelto.\\

Per una migliore comprensione, ad esempio i parametri associati alla tipologia balanced tree sono il branching factor e l'height dell'albero, invece per la tipologia di grafo complete graph vi è un unico parametro da passare al programma, il node number del grafo.\\
L'esempio ovviamente ricopre solo 2 tipologie di grafo, ma ciò vale per ogni tipologia implementata nel programma.\\

A questo punto l'utente è chiamato a scegliere quale tipologia di dato utilizzare per codificare i pesi associati agli archi del grafo, peso flottante (tipo float) o peso intero (tipo int).\\
Possiamo tralasciare il tipo flottante, dato che quest'ultimo, non essendo interessante e significativo per la sperimentazione, è stato tralasciato in favore del tipo intero.\\

L'utente dunque dovrà scegliere i valori massimo e minimo relativi al range all'interno del quale oscilleranno randomicamente i pesi interi associati agli archi del grafo.\\
È possibile scegliere solo pesi interi positivi, ovvero i valori minimo e massimo del range devono essere compresi tra \(0 \geq minimo \geq massimo \geq n\), con \(n\to\infty\).\\

L'utente inoltre dovrà inserire il nome del grafo da creare il quale sarà utilizzato dal programma per creare la sotto porzione di filesystem relativa al grafo generato, ovvero nome-scelto.dir/nomescelto.edgelist, in modo da non creare conflitti tra i dati.\\

A questo punto il programma procederà a scrivere sul filesystem la struttura cartella/file.edgelist relativa al grafo appena creato.\\

Il file nel quale è codificato il grafo generato ha estensione .edgelist (il file .dot come specificato sopra è stato utilizzato solo in fase di debug e quindi non viene considerato nella trattazione).\\

Il file .edgelist è un file di tipo testuale che codifica sotto forma di lista (nodo, nodo, peso) la matrice di adiacenza che descrive il grafo generato.\\
Il file si presenta nella forma qui di seguito (ciascuna coppia (nodo, nodo) codifica un arco al quale viene associato il terzo valore della tupla, ovvero il peso intero).\\

\begin{description}
	\item nodo nodo peso
	\item 0    1    9
	\item 0    2    20
	\item 1    2    15
	\item 2    3    3
	\item ...
\end{description}

I nodi sono generati in modo totalmente dinamico utilizzando valori da 0 a n interi positivi, con n scelto dall'utente in fase di creazione quando richiesto come parametro associato alla tipologia di grafo da generare.\\

Per completezza specifichiamo che la libreria offre i seguenti 4 tipi di grafi.

\begin{itemize}
	\item Graph (grafo senza parallelismo non-orientato)
	\item Directed Graph (grafo senza parallelismo orientato)
	\item MultiGraph (grafo con parallelismo non-orientato)
	\item Directed MultiGraph (grafo con parallelismo orientato)
\end{itemize}

Nel programma è stata implementata solo la tipologia Graph, cioè grafi senza parallelismo non-orientati (con pesi interi positivi associati agli archi e valori interi positivi associati ai nodi) come richiesto dal problema modellato in precedenza, ovvero il gioco della k-colorazione generalizzata.\\

Il programma termina a questo punto l'esecuzione permettendo all'utente di scegliere se disegnare il grafo appena creato attraverso la libreria MatPlotLib, l'utente può saltare l'esecuzione di questa operazione rispondendo negativamente alla richiesta.\\

\subsection{generator.py : MULTIPLE MODE}
\justify
Il funzionamento della modalità MULTIPLE MODE, accessibile selezionando l'opzione MULTIPLE durante la scelta della classe, è quasi del tutto analogo a quello descritto in precedenza, le uniche differenze sono le seguenti.\\

Dopo aver scelto la tipologia di grafo da generare, all'utente verrà chiesto come parametro aggiuntivo il numero di iterazioni relativo all'algoritmo di generazione multipla.\\
In sostanza l'utente dovrà scegliere quanti grafi generare (appartenenti alla tipologia scelta in precedenza).\\

In seguito l'utente dovrà inserire un ulteriore parametro aggiuntivo, ovvero il valore minimo e massimo relativi al range all'interno del quale dovrà oscillare randomicamente il numero di nodi dei grafi da generare.\\
I valori minimo e massimo dovranno ovviamente essere compresi tra \(0 \geq minimo \geq massimo \geq n\), con \(n\to\infty\), come specificato in precedenza.\\

All'utente verrà inoltre chiesto di inserire il nome della cartella nella quale inserire gli output delle generazioni multiple, come nel caso descritto nella sezione SINGLE MODE.\\

A questo punto l'algoritmo di generazione provvederà a creare n grafi (con n scelto dall'utente, come descritto poco sopra) appartenenti alla tipologia scelta (ad esempio complete graph).\\
Ciascun grafo creato avrà un valore randomico di nodi compreso tra \(0 \geq minimo \geq numero di nodi \geq massimo \geq n\).\\

Il programma provverà automaticamente e in modo totalmente dinamico a creare le strutture nel filesystem necessarie a salvare correttamente i file .edgelist relativi a ciascun grafo creato durante la generazione multipla.\\
È stato implementato un processo di assegnamento automatico del nome per ciascun output generato che utilizza il round di iterazione assieme alla tipologia e al numero di nodi del grafo creato, in modo da evitare conflitti, inconsistenza e perdita dei dati.\\

Passiamo ora a descrivere il programma reader.py, il lettore di grafi, nel quale sono includi gli algoritmi per il calcolo degli equilibri di Nash e per il calcolo degli ottimi utilizzando le 2 funzioni di benessere sociale utilitario e egalitario, il vero cuore dell'implementazione.\\


\section{reader.py : il lettore di grafi}
\justify
il programma reader.py è un lettore dinamico di grafi anche esso scritto interamente in linguaggio Python che consente la lettura e la manipolazione dei grafi creati in modo asincrono attraverso l'utilizzo del generatore generator.py.\\

Inoltre il programma consente la modellazione del problema del gioco della k-colorazione generalizzata attraverso un massiccio uso della Standard Library del linguaggio Python.\\

Nel reader.py sono incluse le definizioni degli algoritmi per il calcolo degli equilibri di Nash e quelli per il calcolo dell'ottimo con funzione di benessere utilitario e egalitario.\\
Il programma permette la lettura di un singolo o di molteplici grafi per volta e consente l'esecuzione dei suddetti algoritmi sulle istanze lette.\\

Per rendere meno faticoso il lavoro relativo alla sperimentazione il programma è in grado di raccogliere efficacemente e organizzare i dati derivanti dalle esecuzioni in tempo reale.\\

In modo totalmente dinamico il lettore è in grado di salvare i risultati delle sperimentazioni manipolando le strutture relative al filesystem.\\
Come per il generatore il programma utilizza principalmente e in modo quasi esclusivo la libreria standard del linguaggio Python per eseguire queste operazioni.\\
Anche in questo caso le primitive e le funzioni utilizzate garantiscono la il funzionamento cross-platform e dunque la portabilità del programma.\\ Il tutto è stato ampiamente testato su macchine con sistema POSIX e non, il programma è totalmente ottimizzato e funzionale in questo senso.\\

I file di output per ciascuna esecuzione sono 2, il file .init (file testuale che contiene il salvataggio delle informazioni basilari del grafo, creato dopo aver effettuato la modellazione del problema) e il file.out (file testuale che contiene i risultati finali derivanti dall'esecuzione di uno o più algoritmi).\\

Sia per esecuzioni singole che multiple il risultato prodotto sarà sempre e comunque una coppia file.init / file.out.\\  

Anche in questo caso sono disponibili per l'utente moduli per il disegno dei grafi, in particolare pre e post modellazione e per rappresentare i risultati delle esecuzioni (ad esempio le colorazioni stabili ottenute dal calcolo degli equillibri di Nash).\\
La principale libreria in questo senso è MatPlotLib (la libreria PyGraphViz è stata utilizzata in fase di debug come specificato in precedenza).\\

Per non tediare il lettore confermiamo che anche il programma reader.py fa uso delle medesime librerie addizionali utilizzate nel programma generator.py, il loro uso è però marginale e dunque non verranno trattate, come in precedenza.\\
L'utilizzo più intesivo è relativo alle librerie Pick, per fornire un interfaccia di selezione da console all'utente, e alla libreria Colorama, utilizzata in fase di lettura e debug per colore l'output su console e mettere in risalto i dati fondamentali relativi alle esecuzioni degli algoritmi e alle operazioni essenziali di gestione del programma.\\

Di fondamentale importanza è l'utilizzo della libreria NetworkX che consente la lettura e l'interpretazione delle informazioni relative ai file testuali di creazione .edgelist e la ricostruzione in modo asincrono dei grafi generati in precedenza, in modo da utilizzarli per la sperimentazione.\\

Anche in questo caso qui di seguito vengono riportate le caratteristiche del programma assieme ad un esempio generale di un caso d'uso in modo da descrivere il funzionamento del programma e le operazioni disponibili per l'utente

Sono disponibili per l'utente, in modo speculare e simmetrico rispetto alla definizione del programma generator.py, 2 modalità di funzionamento per la lettura e l'esecuzione, la modalità SINGLE EXEC e la modalità MULTIPLE EXEC.\\
All'avvio del programma l'utente dovrà scegliere una delle 2 modaliltà d'uso attraverso un'interfaccia si selezione da console implementata attraverso l'utilizzo della libreria Pick.\\


\subsection{reader.py : SINGLE EXEC}
\justify
In modalità SINGLE EXEC il programma effettuerà una ricerca globale automatica e dinamica dei file con estensione .edgelist all'interno della cartella gen, la cartella relativa alle generazioni di grafi singoli creata dal generatore generator.py in modalità SINGLE MODE.\\

A questo punto l'utente dovrà selezione il grafo da modellare e sul quale eseguire una sperimentazione utilizzando gli algoritmi forniti all'interno del programma.\\
La scelta è implementata attraverso un'interfaccia di selezione creata con la libreria Pick nella quale apparirà la lista di file .edgelist trovati.\\

Il programma leggerà e interpreterà il contenuto del file.edgelist relativo al grafo selezionato dall'utente e attraverso le funzioni della libreria NetworkX ricostruire l'istanza dell'oggetto matematico desiderato creato in precedenza e sul quale si vuole iniziare una sperimentazione.\\

Ovviamente l'operazione genererà sempre e comunque un'istanza di grafo senza parallelismo non-orientato e con valori interi positivi associati ai nodi e pesi interi positivi associati agli archi (parametri scelti in precedenza, durante la fase di creazione del grafo e ricostruiti dalle funzioni di libreria).\\

In seguito l'utente sarà nuovamente chiamato a scegliere 2 parametri fondamentali per la modellazione del problema, ovvero il numero di colori e valore massimo per il profitto associato a questi ultimi.\\

L'utente potrà scegliere il numero massimo di colori presenti all'interno dell'istanza che si sta modellando.\\
Il numero massimo di colori non può essere superiore al numero di nodi del grafo, altrimenti la sperimentazione perderebbe di senso e in più non verrebbe rispettata la definizione del problema presentata nel Capitolo 2.\\
I colori, come ogni altro parametro del quale non è richiesto un range (valore minimo e massimo), saranno numerati da 0 a n, con n scelto dall'utente e sempre \(n \leq numero di nodi del grafo\).\\

Come struttura dati è stata scelta la lista poichè l'elenco dei colori non necessità di essere manipolato in maniera complessa, non vi è inoltre l'esigenza di effettuare query di ricerca indicizzate e altre operazioni poco efficaci sulle liste.\\
Semplicemente la lista dei colori andrà iterata più volte e in modo innestato durante i vari cicli degli algoritmi implementati.\\
Per la creazione è stata utilizzata la potente list comprehension interna a al linguaggio Python.\\

L'utente inoltre potrà scegliere il valore massimo all'interno del quale oscilleranno randomicamente i profitto associati ai colori per ciascun giocatore.\\
In questo caso non vi sono restrizioni, scelto n, i valori oscilleranno in modo randomico tra 0 e n.\\
I profitti legati ai colori, per definizione del modello potranno essere differenti da giocatore a giocatore, ad esempio il giocatore 0 avrà un profitto di 56 per il colore 0, il giocatore 1 avrà un profitto di 29 per il colore 0 (i valori sono totalmente casuali e servono solo da esempio).\\

Proprio per questo motivo la struttura dati implementata per soddisfare le caratteristiche del modello è un doppio dizionario innestato.\\
Assieme alla struttura relativa alle coppie arco-peso e quella relativa all'associazione nodo-colore che presenteremo in seguito, quest'ultima rappresenta uno dei componenti più utilizzati del programma.\\
È necessaria in questo caso un'implementazione che permetta l'utilizzo di query di ricerca asincrone a doppia chiave (l'operazione più pesante che interessa questa struttura).\\
È stata utilizzata a questo scopo la potente nested dictionary comprehension del linguaggio Python, in modo da eliminare possibilità di conflitto e inconsistenza dei dati, in modo da disambiguare le entry del dizionario in modo efficace e dunque in modo da garantire l'utilizzo di interrogazioni ad accesso diretto utili nel programma.\\
È stata generata la seguente struttura (esempio).

\begin{description}
	\item nodo 0 :: colore 0 : profitto 24, colore 1 : profitto 38, colore 2 : profitto 30, ...
	\item nodo 1 :: colore 0 : profitto 11, colore 1 : profitto 55, colore 2 : profitto 23, ...
	\item nodo 2 :: colore 0 : profitto 14, colore 1 : profitto 65, colore 2 : profitto 26, ...
	\item nodo 3 :: colore 0 : profitto 99, colore 1 : profitto 66, colore 2 : profitto 86, ...
	\item ...
\end{description}

A questo punto viene generata automaticamente la colorazione iniziale per il grafo corrente.\\
Il colore è stato gestito attraverso la struttura dati del dizionario, ad ogni nodo viene associata una singola entry chiave : valore come etichetta, la chiave rappresenta il nome del parametro, ovvero la stringa "color" e il valore rappresenta il colore con il quale è colorato in nodo.\\
Le etichette sono gestite a livello di libreria NetworkX, dunque è stato seguito lo standard esplicato in documentazione.\\
È dunque possibile accedere e manipolare, con facilità e alta velocità computazionale, i dati all'interno dei dizionari che rappresentano i parametri associati al nodo attravero semplici query ad accesso diretto e a singola chiave, ovvero il parametro "color" nel nostro caso.\\
La colorazione iniziale è del tipo seguente.

\begin{description}
	\item nodo 0 : colore 2
	\item nodo 1 : colore 1
	\item nodo 2 : colore 2
	\item nodo 3 : colore 0
	\item ...
\end{description}

Tutti i dati relativi alla modellazione iniziale dell'istanza letta per ricreare le condizioni di partenza del nostro gioco sono salvate nel file.init correlato all'esecuzione corrente.\\
Specifichiamo nuovamente l'assoluta gestione cross-platform del filesystem e l'efficente ottimizzazione eseguita sul lato input / output su file, il tutto è affiancato ovviamente da numerosissimi test su diverse tipologie di macchine.\\

Nel file testuale .init relativo all'esecuzioni vengono inseriti i seguenti parametri.

\begin{itemize}
	\item lista dei colori
	\item colorazione iniziale del grafo
	\item numero di nodi del grafo
	\item profitti associati ai colori per ogni giocatore
	\item lista degli archi del grafo con pesi associati
	\item numero degli archi del grafo
\end{itemize}

È importante specificare che il peso degli archi è gestito in modo del tutto identico a quello relativo al colore dei nodi.\\
Infatti il peso (e gli eventuali altri parametri implentabili in modo nativo grazie alla libreria NetworkX) degli archi si presenta come un dizionario chiave : valore, nel quale la chiave corrisponde al nome del parametro, ovvero la stringa "weight" e il valore rappresenta il vero e proprio peso associato all'arco.\\

Anche qui dunque una struttura dati di questo tipo permette un'alta velocità di calcolo e recupero delle informazioni con query ad accesso diretto a chiave singola, ovvero il nome del parametro richiesto associato all'arco che nel nostro caso è la stringa "weight".\\
La struttura dati si presenta come segue.

\begin{description}
	\item nodo 0  nodo 1  weight : 34
	\item nodo 1  nodo 2  weight : 55
	\item nodo 2  nodo 5  weight : 5
	\item nodo 3  nodo 2  weight : 23
	\item ...
\end{description}

Terminata la creazione del file testuale con estensione .init il programma procede e genera tutte le strutture del filesystem necessarie per salvare correttamente i risultati della sperimentazione corrente.\\
In particolare crea una nuova cartella all'interno della direcotry result (poichè siamo in SINGLE EXEC) in modo dinamico prendendo il nome del grafo corrente importato dall'utente.\\
Assegna il medesimo nome al file .init (e al file .out che vedremo tra poco) che viene generato all'interno del path appena generato.\\

A questo punto l'utente viene chiamato a compiere un'ennesima scelta, l'ultima relativa al flusso di esecuzione corrente.\\
All'utente viene chiesto di scegliere tra le 3 opzioni di calcolo disponibili, ciascuna corrispondete a 1 dei 3 algoritmi implementati.

\begin{itemize}
	\item cacolo della colorazione ottima (ottimo con funzione di benessere sociale utilitaria)
	\item cacolo della colorazione ottima (ottimo con funzione di benessere sociale egalitaria)
	\item cacolo della colorazione stabile (equilibrio di Nash)
	\item esci
\end{itemize}

Vi inoltre un'ulteriore opzione per uscire dal programma, prima dell'esecuzione che potrebbe essere pesante a livello di calcolo e dunque lenta al livello temporale, soprattutto per ciò che concerne il calcolo degli ottimi.\\

Per l'utente che esegue in modalità SINGLE EXEC, questo punto del programma rappresenta un hub di esecuzione.\\
L'utente infatti può eseguire, quante volte vuole, i vari algoritmi (può anche eseguirli tutti sull'istanza corrente o uscire e non fare nulla come specificato poco sopra).\\
Terminata l'esecuzione di uno degli algoritmi, all'utente verrà lasciato il pieno controllo.\\
Quest'ultimo potrà leggere il risultato dell'esecuzione da console e analizzare i vari cicli eseguiti e poi tornare all'hub nel quale potrà avviare una nuova esecuzione o uscire dal programma.\\

Prima di affrontare la descrizione degli algoritmi, il vero cuore dell'implementazione, analizziamo al modalità di funzionamento MULTIPLE EXEC relativa al programma reader.py.\\

\subsection{reader.py : MULTIPLE EXEC}
\justify
Per non tediare il lettore, possiamo specificare che la modalità MULTIPLE EXEC esegue le medesime operazioni di preparazione e modellazione delle varie istanze e salva il risultato di tale operazione in un file testuale estensione .init.\\

Una prima differenza sostanziale è relativa al path in cui vengono cercati i file .edgelist nella fase di scelta della modalità di esecuzione del lettore.\\
Scegliendo MULTIPLE EXEC il programma effettuerà una ricerca globale di tutte le cartelle presenti all'interno della cartella mgen, ovvero la cartella contenente tutti i risultati delle varie generazioni multiple, creata dinamicamente dal generatore di grafi in modalità MULTIPLE MODE.\\

A questo punto l'utente sarà nuovamente interpellato e attraverso un'interfaccia di selezione da console dovrà selezionare la cartella contenente i grafi sui quali desidera fare sperimentazione.\\
Una volta selezionata la cartella il programma utilizzerà tutti i file con estensione .edgelist come istanze dell'esecuzione multipla.\\
In particolare il programma si sviluppa all'interno di un ciclo principale che scorrè tutti i file con estensione .edgelist presenti nella cartella scelta dall'utente.\\

Il ciclo prende un grafo alla volta, opera la fase di pre-esecuzione modellando l'istanza corrente secondo la definzione del problema e poi esegue l'algoritmo per il calcolo della colorazione stabile trovando l'equilibrio di Nash per il grafo corrente.\\
Il ciclo e l'esecuzione, che potrebbe coinvolgere un numero molto grande di grafi, avvengono in maniera totalmente automatica e dunque l'utente può disinteressarsi del programma poichè slegato dal flusso di esecuzione.\\




%\section{Analisi e descrizione degli algoritmi}
%\justify
%
%\subsection{nash_equilibrium : l'algoritmo per il calcolo degli equilibri di Nash}
%\justify
%
%\subsection{utilitarian_social_welfare : l'algoritmo per il calcolo dell'ottimo relativo alla funzione di benessere sociale utilitario}
%\justify
%
%\subsection{egalitarian_social_welfare : l'algoritmo per il calcolo dell'ottimo relativo alla funzione di benessere sociale egalitario}
%\justify